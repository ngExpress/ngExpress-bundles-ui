(function ($) {
  if (typeof $.fn.each2 == 'undefined') {
    $.extend($.fn, {
      each2: function (c) {
        var j = $([0]), i = -1, l = this.length;
        while (++i < l && (j.context = j[0] = this[i]) && c.call(j[0], i, j) !== false);
        return this;
      }
    });
  }
}(jQuery));
(function ($, undefined) {
  'use strict';
  if (window.Select2 !== undefined) {
    return;
  }
  var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer, lastMousePosition = {
      x: 0,
      y: 0
    }, $document, scrollBarDimensions, KEY = {
      TAB: 9,
      ENTER: 13,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      HOME: 36,
      END: 35,
      BACKSPACE: 8,
      DELETE: 46,
      isArrow: function (k) {
        k = k.which ? k.which : k;
        switch (k) {
        case KEY.LEFT:
        case KEY.RIGHT:
        case KEY.UP:
        case KEY.DOWN:
          return true;
        }
        return false;
      },
      isControl: function (e) {
        var k = e.which;
        switch (k) {
        case KEY.SHIFT:
        case KEY.CTRL:
        case KEY.ALT:
          return true;
        }
        if (e.metaKey)
          return true;
        return false;
      },
      isFunctionKey: function (k) {
        k = k.which ? k.which : k;
        return k >= 112 && k <= 123;
      }
    }, MEASURE_SCROLLBAR_TEMPLATE = '<div class=\'select2-measure-scrollbar\'></div>', DIACRITICS = {
      '\u24b6': 'A',
      '\uff21': 'A',
      '\xc0': 'A',
      '\xc1': 'A',
      '\xc2': 'A',
      '\u1ea6': 'A',
      '\u1ea4': 'A',
      '\u1eaa': 'A',
      '\u1ea8': 'A',
      '\xc3': 'A',
      '\u0100': 'A',
      '\u0102': 'A',
      '\u1eb0': 'A',
      '\u1eae': 'A',
      '\u1eb4': 'A',
      '\u1eb2': 'A',
      '\u0226': 'A',
      '\u01e0': 'A',
      '\xc4': 'A',
      '\u01de': 'A',
      '\u1ea2': 'A',
      '\xc5': 'A',
      '\u01fa': 'A',
      '\u01cd': 'A',
      '\u0200': 'A',
      '\u0202': 'A',
      '\u1ea0': 'A',
      '\u1eac': 'A',
      '\u1eb6': 'A',
      '\u1e00': 'A',
      '\u0104': 'A',
      '\u023a': 'A',
      '\u2c6f': 'A',
      '\ua732': 'AA',
      '\xc6': 'AE',
      '\u01fc': 'AE',
      '\u01e2': 'AE',
      '\ua734': 'AO',
      '\ua736': 'AU',
      '\ua738': 'AV',
      '\ua73a': 'AV',
      '\ua73c': 'AY',
      '\u24b7': 'B',
      '\uff22': 'B',
      '\u1e02': 'B',
      '\u1e04': 'B',
      '\u1e06': 'B',
      '\u0243': 'B',
      '\u0182': 'B',
      '\u0181': 'B',
      '\u24b8': 'C',
      '\uff23': 'C',
      '\u0106': 'C',
      '\u0108': 'C',
      '\u010a': 'C',
      '\u010c': 'C',
      '\xc7': 'C',
      '\u1e08': 'C',
      '\u0187': 'C',
      '\u023b': 'C',
      '\ua73e': 'C',
      '\u24b9': 'D',
      '\uff24': 'D',
      '\u1e0a': 'D',
      '\u010e': 'D',
      '\u1e0c': 'D',
      '\u1e10': 'D',
      '\u1e12': 'D',
      '\u1e0e': 'D',
      '\u0110': 'D',
      '\u018b': 'D',
      '\u018a': 'D',
      '\u0189': 'D',
      '\ua779': 'D',
      '\u01f1': 'DZ',
      '\u01c4': 'DZ',
      '\u01f2': 'Dz',
      '\u01c5': 'Dz',
      '\u24ba': 'E',
      '\uff25': 'E',
      '\xc8': 'E',
      '\xc9': 'E',
      '\xca': 'E',
      '\u1ec0': 'E',
      '\u1ebe': 'E',
      '\u1ec4': 'E',
      '\u1ec2': 'E',
      '\u1ebc': 'E',
      '\u0112': 'E',
      '\u1e14': 'E',
      '\u1e16': 'E',
      '\u0114': 'E',
      '\u0116': 'E',
      '\xcb': 'E',
      '\u1eba': 'E',
      '\u011a': 'E',
      '\u0204': 'E',
      '\u0206': 'E',
      '\u1eb8': 'E',
      '\u1ec6': 'E',
      '\u0228': 'E',
      '\u1e1c': 'E',
      '\u0118': 'E',
      '\u1e18': 'E',
      '\u1e1a': 'E',
      '\u0190': 'E',
      '\u018e': 'E',
      '\u24bb': 'F',
      '\uff26': 'F',
      '\u1e1e': 'F',
      '\u0191': 'F',
      '\ua77b': 'F',
      '\u24bc': 'G',
      '\uff27': 'G',
      '\u01f4': 'G',
      '\u011c': 'G',
      '\u1e20': 'G',
      '\u011e': 'G',
      '\u0120': 'G',
      '\u01e6': 'G',
      '\u0122': 'G',
      '\u01e4': 'G',
      '\u0193': 'G',
      '\ua7a0': 'G',
      '\ua77d': 'G',
      '\ua77e': 'G',
      '\u24bd': 'H',
      '\uff28': 'H',
      '\u0124': 'H',
      '\u1e22': 'H',
      '\u1e26': 'H',
      '\u021e': 'H',
      '\u1e24': 'H',
      '\u1e28': 'H',
      '\u1e2a': 'H',
      '\u0126': 'H',
      '\u2c67': 'H',
      '\u2c75': 'H',
      '\ua78d': 'H',
      '\u24be': 'I',
      '\uff29': 'I',
      '\xcc': 'I',
      '\xcd': 'I',
      '\xce': 'I',
      '\u0128': 'I',
      '\u012a': 'I',
      '\u012c': 'I',
      '\u0130': 'I',
      '\xcf': 'I',
      '\u1e2e': 'I',
      '\u1ec8': 'I',
      '\u01cf': 'I',
      '\u0208': 'I',
      '\u020a': 'I',
      '\u1eca': 'I',
      '\u012e': 'I',
      '\u1e2c': 'I',
      '\u0197': 'I',
      '\u24bf': 'J',
      '\uff2a': 'J',
      '\u0134': 'J',
      '\u0248': 'J',
      '\u24c0': 'K',
      '\uff2b': 'K',
      '\u1e30': 'K',
      '\u01e8': 'K',
      '\u1e32': 'K',
      '\u0136': 'K',
      '\u1e34': 'K',
      '\u0198': 'K',
      '\u2c69': 'K',
      '\ua740': 'K',
      '\ua742': 'K',
      '\ua744': 'K',
      '\ua7a2': 'K',
      '\u24c1': 'L',
      '\uff2c': 'L',
      '\u013f': 'L',
      '\u0139': 'L',
      '\u013d': 'L',
      '\u1e36': 'L',
      '\u1e38': 'L',
      '\u013b': 'L',
      '\u1e3c': 'L',
      '\u1e3a': 'L',
      '\u0141': 'L',
      '\u023d': 'L',
      '\u2c62': 'L',
      '\u2c60': 'L',
      '\ua748': 'L',
      '\ua746': 'L',
      '\ua780': 'L',
      '\u01c7': 'LJ',
      '\u01c8': 'Lj',
      '\u24c2': 'M',
      '\uff2d': 'M',
      '\u1e3e': 'M',
      '\u1e40': 'M',
      '\u1e42': 'M',
      '\u2c6e': 'M',
      '\u019c': 'M',
      '\u24c3': 'N',
      '\uff2e': 'N',
      '\u01f8': 'N',
      '\u0143': 'N',
      '\xd1': 'N',
      '\u1e44': 'N',
      '\u0147': 'N',
      '\u1e46': 'N',
      '\u0145': 'N',
      '\u1e4a': 'N',
      '\u1e48': 'N',
      '\u0220': 'N',
      '\u019d': 'N',
      '\ua790': 'N',
      '\ua7a4': 'N',
      '\u01ca': 'NJ',
      '\u01cb': 'Nj',
      '\u24c4': 'O',
      '\uff2f': 'O',
      '\xd2': 'O',
      '\xd3': 'O',
      '\xd4': 'O',
      '\u1ed2': 'O',
      '\u1ed0': 'O',
      '\u1ed6': 'O',
      '\u1ed4': 'O',
      '\xd5': 'O',
      '\u1e4c': 'O',
      '\u022c': 'O',
      '\u1e4e': 'O',
      '\u014c': 'O',
      '\u1e50': 'O',
      '\u1e52': 'O',
      '\u014e': 'O',
      '\u022e': 'O',
      '\u0230': 'O',
      '\xd6': 'O',
      '\u022a': 'O',
      '\u1ece': 'O',
      '\u0150': 'O',
      '\u01d1': 'O',
      '\u020c': 'O',
      '\u020e': 'O',
      '\u01a0': 'O',
      '\u1edc': 'O',
      '\u1eda': 'O',
      '\u1ee0': 'O',
      '\u1ede': 'O',
      '\u1ee2': 'O',
      '\u1ecc': 'O',
      '\u1ed8': 'O',
      '\u01ea': 'O',
      '\u01ec': 'O',
      '\xd8': 'O',
      '\u01fe': 'O',
      '\u0186': 'O',
      '\u019f': 'O',
      '\ua74a': 'O',
      '\ua74c': 'O',
      '\u01a2': 'OI',
      '\ua74e': 'OO',
      '\u0222': 'OU',
      '\u24c5': 'P',
      '\uff30': 'P',
      '\u1e54': 'P',
      '\u1e56': 'P',
      '\u01a4': 'P',
      '\u2c63': 'P',
      '\ua750': 'P',
      '\ua752': 'P',
      '\ua754': 'P',
      '\u24c6': 'Q',
      '\uff31': 'Q',
      '\ua756': 'Q',
      '\ua758': 'Q',
      '\u024a': 'Q',
      '\u24c7': 'R',
      '\uff32': 'R',
      '\u0154': 'R',
      '\u1e58': 'R',
      '\u0158': 'R',
      '\u0210': 'R',
      '\u0212': 'R',
      '\u1e5a': 'R',
      '\u1e5c': 'R',
      '\u0156': 'R',
      '\u1e5e': 'R',
      '\u024c': 'R',
      '\u2c64': 'R',
      '\ua75a': 'R',
      '\ua7a6': 'R',
      '\ua782': 'R',
      '\u24c8': 'S',
      '\uff33': 'S',
      '\u1e9e': 'S',
      '\u015a': 'S',
      '\u1e64': 'S',
      '\u015c': 'S',
      '\u1e60': 'S',
      '\u0160': 'S',
      '\u1e66': 'S',
      '\u1e62': 'S',
      '\u1e68': 'S',
      '\u0218': 'S',
      '\u015e': 'S',
      '\u2c7e': 'S',
      '\ua7a8': 'S',
      '\ua784': 'S',
      '\u24c9': 'T',
      '\uff34': 'T',
      '\u1e6a': 'T',
      '\u0164': 'T',
      '\u1e6c': 'T',
      '\u021a': 'T',
      '\u0162': 'T',
      '\u1e70': 'T',
      '\u1e6e': 'T',
      '\u0166': 'T',
      '\u01ac': 'T',
      '\u01ae': 'T',
      '\u023e': 'T',
      '\ua786': 'T',
      '\ua728': 'TZ',
      '\u24ca': 'U',
      '\uff35': 'U',
      '\xd9': 'U',
      '\xda': 'U',
      '\xdb': 'U',
      '\u0168': 'U',
      '\u1e78': 'U',
      '\u016a': 'U',
      '\u1e7a': 'U',
      '\u016c': 'U',
      '\xdc': 'U',
      '\u01db': 'U',
      '\u01d7': 'U',
      '\u01d5': 'U',
      '\u01d9': 'U',
      '\u1ee6': 'U',
      '\u016e': 'U',
      '\u0170': 'U',
      '\u01d3': 'U',
      '\u0214': 'U',
      '\u0216': 'U',
      '\u01af': 'U',
      '\u1eea': 'U',
      '\u1ee8': 'U',
      '\u1eee': 'U',
      '\u1eec': 'U',
      '\u1ef0': 'U',
      '\u1ee4': 'U',
      '\u1e72': 'U',
      '\u0172': 'U',
      '\u1e76': 'U',
      '\u1e74': 'U',
      '\u0244': 'U',
      '\u24cb': 'V',
      '\uff36': 'V',
      '\u1e7c': 'V',
      '\u1e7e': 'V',
      '\u01b2': 'V',
      '\ua75e': 'V',
      '\u0245': 'V',
      '\ua760': 'VY',
      '\u24cc': 'W',
      '\uff37': 'W',
      '\u1e80': 'W',
      '\u1e82': 'W',
      '\u0174': 'W',
      '\u1e86': 'W',
      '\u1e84': 'W',
      '\u1e88': 'W',
      '\u2c72': 'W',
      '\u24cd': 'X',
      '\uff38': 'X',
      '\u1e8a': 'X',
      '\u1e8c': 'X',
      '\u24ce': 'Y',
      '\uff39': 'Y',
      '\u1ef2': 'Y',
      '\xdd': 'Y',
      '\u0176': 'Y',
      '\u1ef8': 'Y',
      '\u0232': 'Y',
      '\u1e8e': 'Y',
      '\u0178': 'Y',
      '\u1ef6': 'Y',
      '\u1ef4': 'Y',
      '\u01b3': 'Y',
      '\u024e': 'Y',
      '\u1efe': 'Y',
      '\u24cf': 'Z',
      '\uff3a': 'Z',
      '\u0179': 'Z',
      '\u1e90': 'Z',
      '\u017b': 'Z',
      '\u017d': 'Z',
      '\u1e92': 'Z',
      '\u1e94': 'Z',
      '\u01b5': 'Z',
      '\u0224': 'Z',
      '\u2c7f': 'Z',
      '\u2c6b': 'Z',
      '\ua762': 'Z',
      '\u24d0': 'a',
      '\uff41': 'a',
      '\u1e9a': 'a',
      '\xe0': 'a',
      '\xe1': 'a',
      '\xe2': 'a',
      '\u1ea7': 'a',
      '\u1ea5': 'a',
      '\u1eab': 'a',
      '\u1ea9': 'a',
      '\xe3': 'a',
      '\u0101': 'a',
      '\u0103': 'a',
      '\u1eb1': 'a',
      '\u1eaf': 'a',
      '\u1eb5': 'a',
      '\u1eb3': 'a',
      '\u0227': 'a',
      '\u01e1': 'a',
      '\xe4': 'a',
      '\u01df': 'a',
      '\u1ea3': 'a',
      '\xe5': 'a',
      '\u01fb': 'a',
      '\u01ce': 'a',
      '\u0201': 'a',
      '\u0203': 'a',
      '\u1ea1': 'a',
      '\u1ead': 'a',
      '\u1eb7': 'a',
      '\u1e01': 'a',
      '\u0105': 'a',
      '\u2c65': 'a',
      '\u0250': 'a',
      '\ua733': 'aa',
      '\xe6': 'ae',
      '\u01fd': 'ae',
      '\u01e3': 'ae',
      '\ua735': 'ao',
      '\ua737': 'au',
      '\ua739': 'av',
      '\ua73b': 'av',
      '\ua73d': 'ay',
      '\u24d1': 'b',
      '\uff42': 'b',
      '\u1e03': 'b',
      '\u1e05': 'b',
      '\u1e07': 'b',
      '\u0180': 'b',
      '\u0183': 'b',
      '\u0253': 'b',
      '\u24d2': 'c',
      '\uff43': 'c',
      '\u0107': 'c',
      '\u0109': 'c',
      '\u010b': 'c',
      '\u010d': 'c',
      '\xe7': 'c',
      '\u1e09': 'c',
      '\u0188': 'c',
      '\u023c': 'c',
      '\ua73f': 'c',
      '\u2184': 'c',
      '\u24d3': 'd',
      '\uff44': 'd',
      '\u1e0b': 'd',
      '\u010f': 'd',
      '\u1e0d': 'd',
      '\u1e11': 'd',
      '\u1e13': 'd',
      '\u1e0f': 'd',
      '\u0111': 'd',
      '\u018c': 'd',
      '\u0256': 'd',
      '\u0257': 'd',
      '\ua77a': 'd',
      '\u01f3': 'dz',
      '\u01c6': 'dz',
      '\u24d4': 'e',
      '\uff45': 'e',
      '\xe8': 'e',
      '\xe9': 'e',
      '\xea': 'e',
      '\u1ec1': 'e',
      '\u1ebf': 'e',
      '\u1ec5': 'e',
      '\u1ec3': 'e',
      '\u1ebd': 'e',
      '\u0113': 'e',
      '\u1e15': 'e',
      '\u1e17': 'e',
      '\u0115': 'e',
      '\u0117': 'e',
      '\xeb': 'e',
      '\u1ebb': 'e',
      '\u011b': 'e',
      '\u0205': 'e',
      '\u0207': 'e',
      '\u1eb9': 'e',
      '\u1ec7': 'e',
      '\u0229': 'e',
      '\u1e1d': 'e',
      '\u0119': 'e',
      '\u1e19': 'e',
      '\u1e1b': 'e',
      '\u0247': 'e',
      '\u025b': 'e',
      '\u01dd': 'e',
      '\u24d5': 'f',
      '\uff46': 'f',
      '\u1e1f': 'f',
      '\u0192': 'f',
      '\ua77c': 'f',
      '\u24d6': 'g',
      '\uff47': 'g',
      '\u01f5': 'g',
      '\u011d': 'g',
      '\u1e21': 'g',
      '\u011f': 'g',
      '\u0121': 'g',
      '\u01e7': 'g',
      '\u0123': 'g',
      '\u01e5': 'g',
      '\u0260': 'g',
      '\ua7a1': 'g',
      '\u1d79': 'g',
      '\ua77f': 'g',
      '\u24d7': 'h',
      '\uff48': 'h',
      '\u0125': 'h',
      '\u1e23': 'h',
      '\u1e27': 'h',
      '\u021f': 'h',
      '\u1e25': 'h',
      '\u1e29': 'h',
      '\u1e2b': 'h',
      '\u1e96': 'h',
      '\u0127': 'h',
      '\u2c68': 'h',
      '\u2c76': 'h',
      '\u0265': 'h',
      '\u0195': 'hv',
      '\u24d8': 'i',
      '\uff49': 'i',
      '\xec': 'i',
      '\xed': 'i',
      '\xee': 'i',
      '\u0129': 'i',
      '\u012b': 'i',
      '\u012d': 'i',
      '\xef': 'i',
      '\u1e2f': 'i',
      '\u1ec9': 'i',
      '\u01d0': 'i',
      '\u0209': 'i',
      '\u020b': 'i',
      '\u1ecb': 'i',
      '\u012f': 'i',
      '\u1e2d': 'i',
      '\u0268': 'i',
      '\u0131': 'i',
      '\u24d9': 'j',
      '\uff4a': 'j',
      '\u0135': 'j',
      '\u01f0': 'j',
      '\u0249': 'j',
      '\u24da': 'k',
      '\uff4b': 'k',
      '\u1e31': 'k',
      '\u01e9': 'k',
      '\u1e33': 'k',
      '\u0137': 'k',
      '\u1e35': 'k',
      '\u0199': 'k',
      '\u2c6a': 'k',
      '\ua741': 'k',
      '\ua743': 'k',
      '\ua745': 'k',
      '\ua7a3': 'k',
      '\u24db': 'l',
      '\uff4c': 'l',
      '\u0140': 'l',
      '\u013a': 'l',
      '\u013e': 'l',
      '\u1e37': 'l',
      '\u1e39': 'l',
      '\u013c': 'l',
      '\u1e3d': 'l',
      '\u1e3b': 'l',
      '\u017f': 'l',
      '\u0142': 'l',
      '\u019a': 'l',
      '\u026b': 'l',
      '\u2c61': 'l',
      '\ua749': 'l',
      '\ua781': 'l',
      '\ua747': 'l',
      '\u01c9': 'lj',
      '\u24dc': 'm',
      '\uff4d': 'm',
      '\u1e3f': 'm',
      '\u1e41': 'm',
      '\u1e43': 'm',
      '\u0271': 'm',
      '\u026f': 'm',
      '\u24dd': 'n',
      '\uff4e': 'n',
      '\u01f9': 'n',
      '\u0144': 'n',
      '\xf1': 'n',
      '\u1e45': 'n',
      '\u0148': 'n',
      '\u1e47': 'n',
      '\u0146': 'n',
      '\u1e4b': 'n',
      '\u1e49': 'n',
      '\u019e': 'n',
      '\u0272': 'n',
      '\u0149': 'n',
      '\ua791': 'n',
      '\ua7a5': 'n',
      '\u01cc': 'nj',
      '\u24de': 'o',
      '\uff4f': 'o',
      '\xf2': 'o',
      '\xf3': 'o',
      '\xf4': 'o',
      '\u1ed3': 'o',
      '\u1ed1': 'o',
      '\u1ed7': 'o',
      '\u1ed5': 'o',
      '\xf5': 'o',
      '\u1e4d': 'o',
      '\u022d': 'o',
      '\u1e4f': 'o',
      '\u014d': 'o',
      '\u1e51': 'o',
      '\u1e53': 'o',
      '\u014f': 'o',
      '\u022f': 'o',
      '\u0231': 'o',
      '\xf6': 'o',
      '\u022b': 'o',
      '\u1ecf': 'o',
      '\u0151': 'o',
      '\u01d2': 'o',
      '\u020d': 'o',
      '\u020f': 'o',
      '\u01a1': 'o',
      '\u1edd': 'o',
      '\u1edb': 'o',
      '\u1ee1': 'o',
      '\u1edf': 'o',
      '\u1ee3': 'o',
      '\u1ecd': 'o',
      '\u1ed9': 'o',
      '\u01eb': 'o',
      '\u01ed': 'o',
      '\xf8': 'o',
      '\u01ff': 'o',
      '\u0254': 'o',
      '\ua74b': 'o',
      '\ua74d': 'o',
      '\u0275': 'o',
      '\u01a3': 'oi',
      '\u0223': 'ou',
      '\ua74f': 'oo',
      '\u24df': 'p',
      '\uff50': 'p',
      '\u1e55': 'p',
      '\u1e57': 'p',
      '\u01a5': 'p',
      '\u1d7d': 'p',
      '\ua751': 'p',
      '\ua753': 'p',
      '\ua755': 'p',
      '\u24e0': 'q',
      '\uff51': 'q',
      '\u024b': 'q',
      '\ua757': 'q',
      '\ua759': 'q',
      '\u24e1': 'r',
      '\uff52': 'r',
      '\u0155': 'r',
      '\u1e59': 'r',
      '\u0159': 'r',
      '\u0211': 'r',
      '\u0213': 'r',
      '\u1e5b': 'r',
      '\u1e5d': 'r',
      '\u0157': 'r',
      '\u1e5f': 'r',
      '\u024d': 'r',
      '\u027d': 'r',
      '\ua75b': 'r',
      '\ua7a7': 'r',
      '\ua783': 'r',
      '\u24e2': 's',
      '\uff53': 's',
      '\xdf': 's',
      '\u015b': 's',
      '\u1e65': 's',
      '\u015d': 's',
      '\u1e61': 's',
      '\u0161': 's',
      '\u1e67': 's',
      '\u1e63': 's',
      '\u1e69': 's',
      '\u0219': 's',
      '\u015f': 's',
      '\u023f': 's',
      '\ua7a9': 's',
      '\ua785': 's',
      '\u1e9b': 's',
      '\u24e3': 't',
      '\uff54': 't',
      '\u1e6b': 't',
      '\u1e97': 't',
      '\u0165': 't',
      '\u1e6d': 't',
      '\u021b': 't',
      '\u0163': 't',
      '\u1e71': 't',
      '\u1e6f': 't',
      '\u0167': 't',
      '\u01ad': 't',
      '\u0288': 't',
      '\u2c66': 't',
      '\ua787': 't',
      '\ua729': 'tz',
      '\u24e4': 'u',
      '\uff55': 'u',
      '\xf9': 'u',
      '\xfa': 'u',
      '\xfb': 'u',
      '\u0169': 'u',
      '\u1e79': 'u',
      '\u016b': 'u',
      '\u1e7b': 'u',
      '\u016d': 'u',
      '\xfc': 'u',
      '\u01dc': 'u',
      '\u01d8': 'u',
      '\u01d6': 'u',
      '\u01da': 'u',
      '\u1ee7': 'u',
      '\u016f': 'u',
      '\u0171': 'u',
      '\u01d4': 'u',
      '\u0215': 'u',
      '\u0217': 'u',
      '\u01b0': 'u',
      '\u1eeb': 'u',
      '\u1ee9': 'u',
      '\u1eef': 'u',
      '\u1eed': 'u',
      '\u1ef1': 'u',
      '\u1ee5': 'u',
      '\u1e73': 'u',
      '\u0173': 'u',
      '\u1e77': 'u',
      '\u1e75': 'u',
      '\u0289': 'u',
      '\u24e5': 'v',
      '\uff56': 'v',
      '\u1e7d': 'v',
      '\u1e7f': 'v',
      '\u028b': 'v',
      '\ua75f': 'v',
      '\u028c': 'v',
      '\ua761': 'vy',
      '\u24e6': 'w',
      '\uff57': 'w',
      '\u1e81': 'w',
      '\u1e83': 'w',
      '\u0175': 'w',
      '\u1e87': 'w',
      '\u1e85': 'w',
      '\u1e98': 'w',
      '\u1e89': 'w',
      '\u2c73': 'w',
      '\u24e7': 'x',
      '\uff58': 'x',
      '\u1e8b': 'x',
      '\u1e8d': 'x',
      '\u24e8': 'y',
      '\uff59': 'y',
      '\u1ef3': 'y',
      '\xfd': 'y',
      '\u0177': 'y',
      '\u1ef9': 'y',
      '\u0233': 'y',
      '\u1e8f': 'y',
      '\xff': 'y',
      '\u1ef7': 'y',
      '\u1e99': 'y',
      '\u1ef5': 'y',
      '\u01b4': 'y',
      '\u024f': 'y',
      '\u1eff': 'y',
      '\u24e9': 'z',
      '\uff5a': 'z',
      '\u017a': 'z',
      '\u1e91': 'z',
      '\u017c': 'z',
      '\u017e': 'z',
      '\u1e93': 'z',
      '\u1e95': 'z',
      '\u01b6': 'z',
      '\u0225': 'z',
      '\u0240': 'z',
      '\u2c6c': 'z',
      '\ua763': 'z'
    };
  $document = $(document);
  nextUid = function () {
    var counter = 1;
    return function () {
      return counter++;
    };
  }();
  function stripDiacritics(str) {
    var ret, i, l, c;
    if (!str || str.length < 1)
      return str;
    ret = '';
    for (i = 0, l = str.length; i < l; i++) {
      c = str.charAt(i);
      ret += DIACRITICS[c] || c;
    }
    return ret;
  }
  function indexOf(value, array) {
    var i = 0, l = array.length;
    for (; i < l; i = i + 1) {
      if (equal(value, array[i]))
        return i;
    }
    return -1;
  }
  function measureScrollbar() {
    var $template = $(MEASURE_SCROLLBAR_TEMPLATE);
    $template.appendTo('body');
    var dim = {
        width: $template.width() - $template[0].clientWidth,
        height: $template.height() - $template[0].clientHeight
      };
    $template.remove();
    return dim;
  }
  function equal(a, b) {
    if (a === b)
      return true;
    if (a === undefined || b === undefined)
      return false;
    if (a === null || b === null)
      return false;
    if (a.constructor === String)
      return a + '' === b + '';
    if (b.constructor === String)
      return b + '' === a + '';
    return false;
  }
  function splitVal(string, separator) {
    var val, i, l;
    if (string === null || string.length < 1)
      return [];
    val = string.split(separator);
    for (i = 0, l = val.length; i < l; i = i + 1)
      val[i] = $.trim(val[i]);
    return val;
  }
  function getSideBorderPadding(element) {
    return element.outerWidth(false) - element.width();
  }
  function installKeyUpChangeEvent(element) {
    var key = 'keyup-change-value';
    element.on('keydown', function () {
      if ($.data(element, key) === undefined) {
        $.data(element, key, element.val());
      }
    });
    element.on('keyup', function () {
      var val = $.data(element, key);
      if (val !== undefined && element.val() !== val) {
        $.removeData(element, key);
        element.trigger('keyup-change');
      }
    });
  }
  $document.on('mousemove', function (e) {
    lastMousePosition.x = e.pageX;
    lastMousePosition.y = e.pageY;
  });
  function installFilteredMouseMove(element) {
    element.on('mousemove', function (e) {
      var lastpos = lastMousePosition;
      if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
        $(e.target).trigger('mousemove-filtered', e);
      }
    });
  }
  function debounce(quietMillis, fn, ctx) {
    ctx = ctx || undefined;
    var timeout;
    return function () {
      var args = arguments;
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function () {
        fn.apply(ctx, args);
      }, quietMillis);
    };
  }
  function thunk(formula) {
    var evaluated = false, value;
    return function () {
      if (evaluated === false) {
        value = formula();
        evaluated = true;
      }
      return value;
    };
  }
  ;
  function installDebouncedScroll(threshold, element) {
    var notify = debounce(threshold, function (e) {
        element.trigger('scroll-debounced', e);
      });
    element.on('scroll', function (e) {
      if (indexOf(e.target, element.get()) >= 0)
        notify(e);
    });
  }
  function focus($el) {
    if ($el[0] === document.activeElement)
      return;
    window.setTimeout(function () {
      var el = $el[0], pos = $el.val().length, range;
      $el.focus();
      if ($el.is(':visible') && el === document.activeElement) {
        if (el.setSelectionRange) {
          el.setSelectionRange(pos, pos);
        } else if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }
    }, 0);
  }
  function getCursorInfo(el) {
    el = $(el)[0];
    var offset = 0;
    var length = 0;
    if ('selectionStart' in el) {
      offset = el.selectionStart;
      length = el.selectionEnd - offset;
    } else if ('selection' in document) {
      el.focus();
      var sel = document.selection.createRange();
      length = document.selection.createRange().text.length;
      sel.moveStart('character', -el.value.length);
      offset = sel.text.length - length;
    }
    return {
      offset: offset,
      length: length
    };
  }
  function killEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  function killEventImmediately(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function measureTextWidth(e) {
    if (!sizer) {
      var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
      sizer = $(document.createElement('div')).css({
        position: 'absolute',
        left: '-10000px',
        top: '-10000px',
        display: 'none',
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        fontStyle: style.fontStyle,
        fontWeight: style.fontWeight,
        letterSpacing: style.letterSpacing,
        textTransform: style.textTransform,
        whiteSpace: 'nowrap'
      });
      sizer.attr('class', 'select2-sizer');
      $('body').append(sizer);
    }
    sizer.text(e.val());
    return sizer.width();
  }
  function syncCssClasses(dest, src, adapter) {
    var classes, replacements = [], adapted;
    classes = dest.attr('class');
    if (classes) {
      classes = '' + classes;
      $(classes.split(' ')).each2(function () {
        if (this.indexOf('select2-') === 0) {
          replacements.push(this);
        }
      });
    }
    classes = src.attr('class');
    if (classes) {
      classes = '' + classes;
      $(classes.split(' ')).each2(function () {
        if (this.indexOf('select2-') !== 0) {
          adapted = adapter(this);
          if (adapted) {
            replacements.push(adapted);
          }
        }
      });
    }
    dest.attr('class', replacements.join(' '));
  }
  function markMatch(text, term, markup, escapeMarkup) {
    var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())), tl = term.length;
    if (match < 0) {
      markup.push(escapeMarkup(text));
      return;
    }
    markup.push(escapeMarkup(text.substring(0, match)));
    markup.push('<span class=\'select2-match\'>');
    markup.push(escapeMarkup(text.substring(match, match + tl)));
    markup.push('</span>');
    markup.push(escapeMarkup(text.substring(match + tl, text.length)));
  }
  function defaultEscapeMarkup(markup) {
    var replace_map = {
        '\\': '&#92;',
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;',
        '/': '&#47;'
      };
    return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
      return replace_map[match];
    });
  }
  function ajax(options) {
    var timeout, handler = null, quietMillis = options.quietMillis || 100, ajaxUrl = options.url, self = this;
    return function (query) {
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function () {
        var data = options.data, url = ajaxUrl, transport = options.transport || $.fn.select2.ajaxDefaults.transport, deprecated = {
            type: options.type || 'GET',
            cache: options.cache || false,
            jsonpCallback: options.jsonpCallback || undefined,
            dataType: options.dataType || 'json'
          }, params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);
        data = data ? data.call(self, query.term, query.page, query.context) : null;
        url = typeof url === 'function' ? url.call(self, query.term, query.page, query.context) : url;
        if (handler) {
          handler.abort();
        }
        if (options.params) {
          if ($.isFunction(options.params)) {
            $.extend(params, options.params.call(self));
          } else {
            $.extend(params, options.params);
          }
        }
        $.extend(params, {
          url: url,
          dataType: options.dataType,
          data: data,
          success: function (data) {
            var results = options.results(data, query.page);
            query.callback(results);
          }
        });
        handler = transport.call(self, params);
      }, quietMillis);
    };
  }
  function local(options) {
    var data = options, dataText, tmp, text = function (item) {
        return '' + item.text;
      };
    if ($.isArray(data)) {
      tmp = data;
      data = { results: tmp };
    }
    if ($.isFunction(data) === false) {
      tmp = data;
      data = function () {
        return tmp;
      };
    }
    var dataItem = data();
    if (dataItem.text) {
      text = dataItem.text;
      if (!$.isFunction(text)) {
        dataText = dataItem.text;
        text = function (item) {
          return item[dataText];
        };
      }
    }
    return function (query) {
      var t = query.term, filtered = { results: [] }, process;
      if (t === '') {
        query.callback(data());
        return;
      }
      process = function (datum, collection) {
        var group, attr;
        datum = datum[0];
        if (datum.children) {
          group = {};
          for (attr in datum) {
            if (datum.hasOwnProperty(attr))
              group[attr] = datum[attr];
          }
          group.children = [];
          $(datum.children).each2(function (i, childDatum) {
            process(childDatum, group.children);
          });
          if (group.children.length || query.matcher(t, text(group), datum)) {
            collection.push(group);
          }
        } else {
          if (query.matcher(t, text(datum), datum)) {
            collection.push(datum);
          }
        }
      };
      $(data().results).each2(function (i, datum) {
        process(datum, filtered.results);
      });
      query.callback(filtered);
    };
  }
  function tags(data) {
    var isFunc = $.isFunction(data);
    return function (query) {
      var t = query.term, filtered = { results: [] };
      $(isFunc ? data() : data).each(function () {
        var isObject = this.text !== undefined, text = isObject ? this.text : this;
        if (t === '' || query.matcher(t, text)) {
          filtered.results.push(isObject ? this : {
            id: this,
            text: this
          });
        }
      });
      query.callback(filtered);
    };
  }
  function checkFormatter(formatter, formatterName) {
    if ($.isFunction(formatter))
      return true;
    if (!formatter)
      return false;
    throw new Error(formatterName + ' must be a function or a falsy value');
  }
  function evaluate(val) {
    return $.isFunction(val) ? val() : val;
  }
  function countResults(results) {
    var count = 0;
    $.each(results, function (i, item) {
      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    });
    return count;
  }
  function defaultTokenizer(input, selection, selectCallback, opts) {
    var original = input, dupe = false, token, index, i, l, separator;
    if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1)
      return undefined;
    while (true) {
      index = -1;
      for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
        separator = opts.tokenSeparators[i];
        index = input.indexOf(separator);
        if (index >= 0)
          break;
      }
      if (index < 0)
        break;
      token = input.substring(0, index);
      input = input.substring(index + separator.length);
      if (token.length > 0) {
        token = opts.createSearchChoice.call(this, token, selection);
        if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
          dupe = false;
          for (i = 0, l = selection.length; i < l; i++) {
            if (equal(opts.id(token), opts.id(selection[i]))) {
              dupe = true;
              break;
            }
          }
          if (!dupe)
            selectCallback(token);
        }
      }
    }
    if (original !== input)
      return input;
  }
  function clazz(SuperClass, methods) {
    var constructor = function () {
    };
    constructor.prototype = new SuperClass();
    constructor.prototype.constructor = constructor;
    constructor.prototype.parent = SuperClass.prototype;
    constructor.prototype = $.extend(constructor.prototype, methods);
    return constructor;
  }
  AbstractSelect2 = clazz(Object, {
    bind: function (func) {
      var self = this;
      return function () {
        func.apply(self, arguments);
      };
    },
    init: function (opts) {
      var results, search, resultsSelector = '.select2-results';
      this.opts = opts = this.prepareOpts(opts);
      this.id = opts.id;
      if (opts.element.data('select2') !== undefined && opts.element.data('select2') !== null) {
        opts.element.data('select2').destroy();
      }
      this.container = this.createContainer();
      this.containerId = 's2id_' + (opts.element.attr('id') || 'autogen' + nextUid());
      this.containerSelector = '#' + this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
      this.container.attr('id', this.containerId);
      this.body = thunk(function () {
        return opts.element.closest('body');
      });
      syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
      this.container.attr('style', opts.element.attr('style'));
      this.container.css(evaluate(opts.containerCss));
      this.container.addClass(evaluate(opts.containerCssClass));
      this.elementTabIndex = this.opts.element.attr('tabindex');
      this.opts.element.data('select2', this).attr('tabindex', '-1').before(this.container).on('click.select2', killEvent);
      this.container.data('select2', this);
      this.dropdown = this.container.find('.select2-drop');
      syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
      this.dropdown.addClass(evaluate(opts.dropdownCssClass));
      this.dropdown.data('select2', this);
      this.dropdown.on('click', killEvent);
      this.results = results = this.container.find(resultsSelector);
      this.search = search = this.container.find('input.select2-input');
      this.queryCount = 0;
      this.resultsPage = 0;
      this.context = null;
      this.initContainer();
      this.container.on('click', killEvent);
      installFilteredMouseMove(this.results);
      this.dropdown.on('mousemove-filtered touchstart touchmove touchend', resultsSelector, this.bind(this.highlightUnderEvent));
      installDebouncedScroll(80, this.results);
      this.dropdown.on('scroll-debounced', resultsSelector, this.bind(this.loadMoreIfNeeded));
      $(this.container).on('change', '.select2-input', function (e) {
        e.stopPropagation();
      });
      $(this.dropdown).on('change', '.select2-input', function (e) {
        e.stopPropagation();
      });
      if ($.fn.mousewheel) {
        results.mousewheel(function (e, delta, deltaX, deltaY) {
          var top = results.scrollTop();
          if (deltaY > 0 && top - deltaY <= 0) {
            results.scrollTop(0);
            killEvent(e);
          } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
            results.scrollTop(results.get(0).scrollHeight - results.height());
            killEvent(e);
          }
        });
      }
      installKeyUpChangeEvent(search);
      search.on('keyup-change input paste', this.bind(this.updateResults));
      search.on('focus', function () {
        search.addClass('select2-focused');
      });
      search.on('blur', function () {
        search.removeClass('select2-focused');
      });
      this.dropdown.on('mouseup', resultsSelector, this.bind(function (e) {
        if ($(e.target).closest('.select2-result-selectable').length > 0) {
          this.highlightUnderEvent(e);
          this.selectHighlighted(e);
        }
      }));
      this.dropdown.on('click mouseup mousedown', function (e) {
        e.stopPropagation();
      });
      if ($.isFunction(this.opts.initSelection)) {
        this.initSelection();
        this.monitorSource();
      }
      if (opts.maximumInputLength !== null) {
        this.search.attr('maxlength', opts.maximumInputLength);
      }
      var disabled = opts.element.prop('disabled');
      if (disabled === undefined)
        disabled = false;
      this.enable(!disabled);
      var readonly = opts.element.prop('readonly');
      if (readonly === undefined)
        readonly = false;
      this.readonly(readonly);
      scrollBarDimensions = scrollBarDimensions || measureScrollbar();
      this.autofocus = opts.element.prop('autofocus');
      opts.element.prop('autofocus', false);
      if (this.autofocus)
        this.focus();
      this.nextSearchTerm = undefined;
    },
    destroy: function () {
      var element = this.opts.element, select2 = element.data('select2');
      this.close();
      if (this.propertyObserver) {
        delete this.propertyObserver;
        this.propertyObserver = null;
      }
      if (select2 !== undefined) {
        select2.container.remove();
        select2.dropdown.remove();
        element.removeClass('select2-offscreen').removeData('select2').off('.select2').prop('autofocus', this.autofocus || false);
        if (this.elementTabIndex) {
          element.attr({ tabindex: this.elementTabIndex });
        } else {
          element.removeAttr('tabindex');
        }
        element.show();
      }
    },
    optionToData: function (element) {
      if (element.is('option')) {
        return {
          id: element.prop('value'),
          text: element.text(),
          element: element.get(),
          css: element.attr('class'),
          disabled: element.prop('disabled'),
          locked: equal(element.attr('locked'), 'locked') || equal(element.data('locked'), true)
        };
      } else if (element.is('optgroup')) {
        return {
          text: element.attr('label'),
          children: [],
          element: element.get(),
          css: element.attr('class')
        };
      }
    },
    prepareOpts: function (opts) {
      var element, select, idKey, ajaxUrl, self = this;
      element = opts.element;
      if (element.get(0).tagName.toLowerCase() === 'select') {
        this.select = select = opts.element;
      }
      if (select) {
        $.each([
          'id',
          'multiple',
          'ajax',
          'query',
          'createSearchChoice',
          'initSelection',
          'data',
          'tags'
        ], function () {
          if (this in opts) {
            throw new Error('Option \'' + this + '\' is not allowed for Select2 when attached to a <select> element.');
          }
        });
      }
      opts = $.extend({}, {
        populateResults: function (container, results, query) {
          var populate, id = this.opts.id;
          populate = function (results, container, depth) {
            var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;
            results = opts.sortResults(results, container, query);
            for (i = 0, l = results.length; i < l; i = i + 1) {
              result = results[i];
              disabled = result.disabled === true;
              selectable = !disabled && id(result) !== undefined;
              compound = result.children && result.children.length > 0;
              node = $('<li></li>');
              node.addClass('select2-results-dept-' + depth);
              node.addClass('select2-result');
              node.addClass(selectable ? 'select2-result-selectable' : 'select2-result-unselectable');
              if (disabled) {
                node.addClass('select2-disabled');
              }
              if (compound) {
                node.addClass('select2-result-with-children');
              }
              node.addClass(self.opts.formatResultCssClass(result));
              label = $(document.createElement('div'));
              label.addClass('select2-result-label');
              formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
              if (formatted !== undefined) {
                label.html(formatted);
              }
              node.append(label);
              if (compound) {
                innerContainer = $('<ul></ul>');
                innerContainer.addClass('select2-result-sub');
                populate(result.children, innerContainer, depth + 1);
                node.append(innerContainer);
              }
              node.data('select2-data', result);
              container.append(node);
            }
          };
          populate(results, container, 0);
        }
      }, $.fn.select2.defaults, opts);
      if (typeof opts.id !== 'function') {
        idKey = opts.id;
        opts.id = function (e) {
          return e[idKey];
        };
      }
      if ($.isArray(opts.element.data('select2Tags'))) {
        if ('tags' in opts) {
          throw 'tags specified as both an attribute \'data-select2-tags\' and in options of Select2 ' + opts.element.attr('id');
        }
        opts.tags = opts.element.data('select2Tags');
      }
      if (select) {
        opts.query = this.bind(function (query) {
          var data = {
              results: [],
              more: false
            }, term = query.term, children, placeholderOption, process;
          process = function (element, collection) {
            var group;
            if (element.is('option')) {
              if (query.matcher(term, element.text(), element)) {
                collection.push(self.optionToData(element));
              }
            } else if (element.is('optgroup')) {
              group = self.optionToData(element);
              element.children().each2(function (i, elm) {
                process(elm, group.children);
              });
              if (group.children.length > 0) {
                collection.push(group);
              }
            }
          };
          children = element.children();
          if (this.getPlaceholder() !== undefined && children.length > 0) {
            placeholderOption = this.getPlaceholderOption();
            if (placeholderOption) {
              children = children.not(placeholderOption);
            }
          }
          children.each2(function (i, elm) {
            process(elm, data.results);
          });
          query.callback(data);
        });
        opts.id = function (e) {
          return e.id;
        };
        opts.formatResultCssClass = function (data) {
          return data.css;
        };
      } else {
        if (!('query' in opts)) {
          if ('ajax' in opts) {
            ajaxUrl = opts.element.data('ajax-url');
            if (ajaxUrl && ajaxUrl.length > 0) {
              opts.ajax.url = ajaxUrl;
            }
            opts.query = ajax.call(opts.element, opts.ajax);
          } else if ('data' in opts) {
            opts.query = local(opts.data);
          } else if ('tags' in opts) {
            opts.query = tags(opts.tags);
            if (opts.createSearchChoice === undefined) {
              opts.createSearchChoice = function (term) {
                return {
                  id: $.trim(term),
                  text: $.trim(term)
                };
              };
            }
            if (opts.initSelection === undefined) {
              opts.initSelection = function (element, callback) {
                var data = [];
                $(splitVal(element.val(), opts.separator)).each(function () {
                  var obj = {
                      id: this,
                      text: this
                    }, tags = opts.tags;
                  if ($.isFunction(tags))
                    tags = tags();
                  $(tags).each(function () {
                    if (equal(this.id, obj.id)) {
                      obj = this;
                      return false;
                    }
                  });
                  data.push(obj);
                });
                callback(data);
              };
            }
          }
        }
      }
      if (typeof opts.query !== 'function') {
        throw 'query function not defined for Select2 ' + opts.element.attr('id');
      }
      return opts;
    },
    monitorSource: function () {
      var el = this.opts.element, sync, observer;
      el.on('change.select2', this.bind(function (e) {
        if (this.opts.element.data('select2-change-triggered') !== true) {
          this.initSelection();
        }
      }));
      sync = this.bind(function () {
        var disabled = el.prop('disabled');
        if (disabled === undefined)
          disabled = false;
        this.enable(!disabled);
        var readonly = el.prop('readonly');
        if (readonly === undefined)
          readonly = false;
        this.readonly(readonly);
        syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
        this.container.addClass(evaluate(this.opts.containerCssClass));
        syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
        this.dropdown.addClass(evaluate(this.opts.dropdownCssClass));
      });
      el.on('propertychange.select2', sync);
      if (this.mutationCallback === undefined) {
        this.mutationCallback = function (mutations) {
          mutations.forEach(sync);
        };
      }
      observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
      if (observer !== undefined) {
        if (this.propertyObserver) {
          delete this.propertyObserver;
          this.propertyObserver = null;
        }
        this.propertyObserver = new observer(this.mutationCallback);
        this.propertyObserver.observe(el.get(0), {
          attributes: true,
          subtree: false
        });
      }
    },
    triggerSelect: function (data) {
      var evt = $.Event('select2-selecting', {
          val: this.id(data),
          object: data
        });
      this.opts.element.trigger(evt);
      return !evt.isDefaultPrevented();
    },
    triggerChange: function (details) {
      details = details || {};
      details = $.extend({}, details, {
        type: 'change',
        val: this.val()
      });
      this.opts.element.data('select2-change-triggered', true);
      this.opts.element.trigger(details);
      this.opts.element.data('select2-change-triggered', false);
      this.opts.element.click();
      if (this.opts.blurOnChange)
        this.opts.element.blur();
    },
    isInterfaceEnabled: function () {
      return this.enabledInterface === true;
    },
    enableInterface: function () {
      var enabled = this._enabled && !this._readonly, disabled = !enabled;
      if (enabled === this.enabledInterface)
        return false;
      this.container.toggleClass('select2-container-disabled', disabled);
      this.close();
      this.enabledInterface = enabled;
      return true;
    },
    enable: function (enabled) {
      if (enabled === undefined)
        enabled = true;
      if (this._enabled === enabled)
        return;
      this._enabled = enabled;
      this.opts.element.prop('disabled', !enabled);
      this.enableInterface();
    },
    disable: function () {
      this.enable(false);
    },
    readonly: function (enabled) {
      if (enabled === undefined)
        enabled = false;
      if (this._readonly === enabled)
        return false;
      this._readonly = enabled;
      this.opts.element.prop('readonly', enabled);
      this.enableInterface();
      return true;
    },
    opened: function () {
      return this.container.hasClass('select2-dropdown-open');
    },
    positionDropdown: function () {
      var $dropdown = this.dropdown, offset = this.container.offset(), height = this.container.outerHeight(false), width = this.container.outerWidth(false), dropHeight = $dropdown.outerHeight(false), $window = $(window), windowWidth = $window.width(), windowHeight = $window.height(), viewPortRight = $window.scrollLeft() + windowWidth, viewportBottom = $window.scrollTop() + windowHeight, dropTop = offset.top + height, dropLeft = offset.left, enoughRoomBelow = dropTop + dropHeight <= viewportBottom, enoughRoomAbove = offset.top - dropHeight >= this.body().scrollTop(), dropWidth = $dropdown.outerWidth(false), enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight, aboveNow = $dropdown.hasClass('select2-drop-above'), bodyOffset, above, changeDirection, css, resultsListNode;
      if (aboveNow) {
        above = true;
        if (!enoughRoomAbove && enoughRoomBelow) {
          changeDirection = true;
          above = false;
        }
      } else {
        above = false;
        if (!enoughRoomBelow && enoughRoomAbove) {
          changeDirection = true;
          above = true;
        }
      }
      if (changeDirection) {
        $dropdown.hide();
        offset = this.container.offset();
        height = this.container.outerHeight(false);
        width = this.container.outerWidth(false);
        dropHeight = $dropdown.outerHeight(false);
        viewPortRight = $window.scrollLeft() + windowWidth;
        viewportBottom = $window.scrollTop() + windowHeight;
        dropTop = offset.top + height;
        dropLeft = offset.left;
        dropWidth = $dropdown.outerWidth(false);
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
        $dropdown.show();
      }
      if (this.opts.dropdownAutoWidth) {
        resultsListNode = $('.select2-results', $dropdown)[0];
        $dropdown.addClass('select2-drop-auto-width');
        $dropdown.css('width', '');
        dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
        dropWidth > width ? width = dropWidth : dropWidth = width;
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
      } else {
        this.container.removeClass('select2-drop-auto-width');
      }
      if (this.body().css('position') !== 'static') {
        bodyOffset = this.body().offset();
        dropTop -= bodyOffset.top;
        dropLeft -= bodyOffset.left;
      }
      if (!enoughRoomOnRight) {
        dropLeft = offset.left + width - dropWidth;
      }
      css = {
        left: dropLeft,
        width: width
      };
      if (above) {
        css.bottom = windowHeight - offset.top;
        css.top = 'auto';
        this.container.addClass('select2-drop-above');
        $dropdown.addClass('select2-drop-above');
      } else {
        css.top = dropTop;
        css.bottom = 'auto';
        this.container.removeClass('select2-drop-above');
        $dropdown.removeClass('select2-drop-above');
      }
      css = $.extend(css, evaluate(this.opts.dropdownCss));
      $dropdown.css(css);
    },
    shouldOpen: function () {
      var event;
      if (this.opened())
        return false;
      if (this._enabled === false || this._readonly === true)
        return false;
      event = $.Event('select2-opening');
      this.opts.element.trigger(event);
      return !event.isDefaultPrevented();
    },
    clearDropdownAlignmentPreference: function () {
      this.container.removeClass('select2-drop-above');
      this.dropdown.removeClass('select2-drop-above');
    },
    open: function () {
      if (!this.shouldOpen())
        return false;
      this.opening();
      return true;
    },
    opening: function () {
      var cid = this.containerId, scroll = 'scroll.' + cid, resize = 'resize.' + cid, orient = 'orientationchange.' + cid, mask;
      this.container.addClass('select2-dropdown-open').addClass('select2-container-active');
      this.clearDropdownAlignmentPreference();
      if (this.dropdown[0] !== this.body().children().last()[0]) {
        this.dropdown.detach().appendTo(this.body());
      }
      mask = $('#select2-drop-mask');
      if (mask.length == 0) {
        mask = $(document.createElement('div'));
        mask.attr('id', 'select2-drop-mask').attr('class', 'select2-drop-mask');
        mask.hide();
        mask.appendTo(this.body());
        mask.on('mousedown touchstart click', function (e) {
          var dropdown = $('#select2-drop'), self;
          if (dropdown.length > 0) {
            self = dropdown.data('select2');
            if (self.opts.selectOnBlur) {
              self.selectHighlighted({ noFocus: true });
            }
            self.close({ focus: true });
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }
      if (this.dropdown.prev()[0] !== mask[0]) {
        this.dropdown.before(mask);
      }
      $('#select2-drop').removeAttr('id');
      this.dropdown.attr('id', 'select2-drop');
      mask.show();
      this.positionDropdown();
      this.dropdown.show();
      this.positionDropdown();
      this.dropdown.addClass('select2-drop-active');
      var that = this;
      this.container.parents().add(window).each(function () {
        $(this).on(resize + ' ' + scroll + ' ' + orient, function (e) {
          that.positionDropdown();
        });
      });
    },
    close: function () {
      if (!this.opened())
        return;
      var cid = this.containerId, scroll = 'scroll.' + cid, resize = 'resize.' + cid, orient = 'orientationchange.' + cid;
      this.container.parents().add(window).each(function () {
        $(this).off(scroll).off(resize).off(orient);
      });
      this.clearDropdownAlignmentPreference();
      $('#select2-drop-mask').hide();
      this.dropdown.removeAttr('id');
      this.dropdown.hide();
      this.container.removeClass('select2-dropdown-open').removeClass('select2-container-active');
      this.results.empty();
      this.clearSearch();
      this.search.removeClass('select2-active');
      this.opts.element.trigger($.Event('select2-close'));
    },
    externalSearch: function (term) {
      this.open();
      this.search.val(term);
      this.updateResults(false);
    },
    clearSearch: function () {
    },
    getMaximumSelectionSize: function () {
      return evaluate(this.opts.maximumSelectionSize);
    },
    ensureHighlightVisible: function () {
      var results = this.results, children, index, child, hb, rb, y, more;
      index = this.highlight();
      if (index < 0)
        return;
      if (index == 0) {
        results.scrollTop(0);
        return;
      }
      children = this.findHighlightableChoices().find('.select2-result-label');
      child = $(children[index]);
      hb = child.offset().top + child.outerHeight(true);
      if (index === children.length - 1) {
        more = results.find('li.select2-more-results');
        if (more.length > 0) {
          hb = more.offset().top + more.outerHeight(true);
        }
      }
      rb = results.offset().top + results.outerHeight(true);
      if (hb > rb) {
        results.scrollTop(results.scrollTop() + (hb - rb));
      }
      y = child.offset().top - results.offset().top;
      if (y < 0 && child.css('display') != 'none') {
        results.scrollTop(results.scrollTop() + y);
      }
    },
    findHighlightableChoices: function () {
      return this.results.find('.select2-result-selectable:not(.select2-disabled, .select2-selected)');
    },
    moveHighlight: function (delta) {
      var choices = this.findHighlightableChoices(), index = this.highlight();
      while (index > -1 && index < choices.length) {
        index += delta;
        var choice = $(choices[index]);
        if (choice.hasClass('select2-result-selectable') && !choice.hasClass('select2-disabled') && !choice.hasClass('select2-selected')) {
          this.highlight(index);
          break;
        }
      }
    },
    highlight: function (index) {
      var choices = this.findHighlightableChoices(), choice, data;
      if (arguments.length === 0) {
        return indexOf(choices.filter('.select2-highlighted')[0], choices.get());
      }
      if (index >= choices.length)
        index = choices.length - 1;
      if (index < 0)
        index = 0;
      this.removeHighlight();
      choice = $(choices[index]);
      choice.addClass('select2-highlighted');
      this.ensureHighlightVisible();
      data = choice.data('select2-data');
      if (data) {
        this.opts.element.trigger({
          type: 'select2-highlight',
          val: this.id(data),
          choice: data
        });
      }
    },
    removeHighlight: function () {
      this.results.find('.select2-highlighted').removeClass('select2-highlighted');
    },
    countSelectableResults: function () {
      return this.findHighlightableChoices().length;
    },
    highlightUnderEvent: function (event) {
      var el = $(event.target).closest('.select2-result-selectable');
      if (el.length > 0 && !el.is('.select2-highlighted')) {
        var choices = this.findHighlightableChoices();
        this.highlight(choices.index(el));
      } else if (el.length == 0) {
        this.removeHighlight();
      }
    },
    loadMoreIfNeeded: function () {
      var results = this.results, more = results.find('li.select2-more-results'), below, page = this.resultsPage + 1, self = this, term = this.search.val(), context = this.context;
      if (more.length === 0)
        return;
      below = more.offset().top - results.offset().top - results.height();
      if (below <= this.opts.loadMorePadding) {
        more.addClass('select2-active');
        this.opts.query({
          element: this.opts.element,
          term: term,
          page: page,
          context: context,
          matcher: this.opts.matcher,
          callback: this.bind(function (data) {
            if (!self.opened())
              return;
            self.opts.populateResults.call(this, results, data.results, {
              term: term,
              page: page,
              context: context
            });
            self.postprocessResults(data, false, false);
            if (data.more === true) {
              more.detach().appendTo(results).text(self.opts.formatLoadMore(page + 1));
              window.setTimeout(function () {
                self.loadMoreIfNeeded();
              }, 10);
            } else {
              more.remove();
            }
            self.positionDropdown();
            self.resultsPage = page;
            self.context = data.context;
            this.opts.element.trigger({
              type: 'select2-loaded',
              items: data
            });
          })
        });
      }
    },
    tokenize: function () {
    },
    updateResults: function (initial) {
      var search = this.search, results = this.results, opts = this.opts, data, self = this, input, term = search.val(), lastTerm = $.data(this.container, 'select2-last-term'), queryNumber;
      if (initial !== true && lastTerm && equal(term, lastTerm))
        return;
      $.data(this.container, 'select2-last-term', term);
      if (initial !== true && (this.showSearchInput === false || !this.opened())) {
        return;
      }
      function postRender() {
        search.removeClass('select2-active');
        self.positionDropdown();
      }
      function render(html) {
        results.html(html);
        postRender();
      }
      queryNumber = ++this.queryCount;
      var maxSelSize = this.getMaximumSelectionSize();
      if (maxSelSize >= 1) {
        data = this.data();
        if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, 'formatSelectionTooBig')) {
          render('<li class=\'select2-selection-limit\'>' + opts.formatSelectionTooBig(maxSelSize) + '</li>');
          return;
        }
      }
      if (search.val().length < opts.minimumInputLength) {
        if (checkFormatter(opts.formatInputTooShort, 'formatInputTooShort')) {
          render('<li class=\'select2-no-results\'>' + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + '</li>');
        } else {
          render('');
        }
        if (initial && this.showSearch)
          this.showSearch(true);
        return;
      }
      if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
        if (checkFormatter(opts.formatInputTooLong, 'formatInputTooLong')) {
          render('<li class=\'select2-no-results\'>' + opts.formatInputTooLong(search.val(), opts.maximumInputLength) + '</li>');
        } else {
          render('');
        }
        return;
      }
      if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
        render('<li class=\'select2-searching\'>' + opts.formatSearching() + '</li>');
      }
      search.addClass('select2-active');
      this.removeHighlight();
      input = this.tokenize();
      if (input != undefined && input != null) {
        search.val(input);
      }
      this.resultsPage = 1;
      opts.query({
        element: opts.element,
        term: search.val(),
        page: this.resultsPage,
        context: null,
        matcher: opts.matcher,
        callback: this.bind(function (data) {
          var def;
          if (queryNumber != this.queryCount) {
            return;
          }
          if (!this.opened()) {
            this.search.removeClass('select2-active');
            return;
          }
          this.context = data.context === undefined ? null : data.context;
          if (this.opts.createSearchChoice && search.val() !== '') {
            def = this.opts.createSearchChoice.call(self, search.val(), data.results);
            if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
              if ($(data.results).filter(function () {
                  return equal(self.id(this), self.id(def));
                }).length === 0) {
                data.results.unshift(def);
              }
            }
          }
          if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, 'formatNoMatches')) {
            render('<li class=\'select2-no-results\'>' + opts.formatNoMatches(search.val()) + '</li>');
            return;
          }
          results.empty();
          self.opts.populateResults.call(this, results, data.results, {
            term: search.val(),
            page: this.resultsPage,
            context: null
          });
          if (data.more === true && checkFormatter(opts.formatLoadMore, 'formatLoadMore')) {
            results.append('<li class=\'select2-more-results\'>' + self.opts.escapeMarkup(opts.formatLoadMore(this.resultsPage)) + '</li>');
            window.setTimeout(function () {
              self.loadMoreIfNeeded();
            }, 10);
          }
          this.postprocessResults(data, initial);
          postRender();
          this.opts.element.trigger({
            type: 'select2-loaded',
            items: data
          });
        })
      });
    },
    cancel: function () {
      this.close();
    },
    blur: function () {
      if (this.opts.selectOnBlur)
        this.selectHighlighted({ noFocus: true });
      this.close();
      this.container.removeClass('select2-container-active');
      if (this.search[0] === document.activeElement) {
        this.search.blur();
      }
      this.clearSearch();
      this.selection.find('.select2-search-choice-focus').removeClass('select2-search-choice-focus');
    },
    focusSearch: function () {
      focus(this.search);
    },
    selectHighlighted: function (options) {
      var index = this.highlight(), highlighted = this.results.find('.select2-highlighted'), data = highlighted.closest('.select2-result').data('select2-data');
      if (data) {
        this.highlight(index);
        this.onSelect(data, options);
      } else if (options && options.noFocus) {
        this.close();
      }
    },
    getPlaceholder: function () {
      var placeholderOption;
      return this.opts.element.attr('placeholder') || this.opts.element.attr('data-placeholder') || this.opts.element.data('placeholder') || this.opts.placeholder || ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
    },
    getPlaceholderOption: function () {
      if (this.select) {
        var firstOption = this.select.children('option').first();
        if (this.opts.placeholderOption !== undefined) {
          return this.opts.placeholderOption === 'first' && firstOption || typeof this.opts.placeholderOption === 'function' && this.opts.placeholderOption(this.select);
        } else if (firstOption.text() === '' && firstOption.val() === '') {
          return firstOption;
        }
      }
    },
    initContainerWidth: function () {
      function resolveContainerWidth() {
        var style, attrs, matches, i, l, attr;
        if (this.opts.width === 'off') {
          return null;
        } else if (this.opts.width === 'element') {
          return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
        } else if (this.opts.width === 'copy' || this.opts.width === 'resolve') {
          style = this.opts.element.attr('style');
          if (style !== undefined) {
            attrs = style.split(';');
            for (i = 0, l = attrs.length; i < l; i = i + 1) {
              attr = attrs[i].replace(/\s/g, '');
              matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
              if (matches !== null && matches.length >= 1)
                return matches[1];
            }
          }
          if (this.opts.width === 'resolve') {
            style = this.opts.element.css('width');
            if (style.indexOf('%') > 0)
              return style;
            return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
          }
          return null;
        } else if ($.isFunction(this.opts.width)) {
          return this.opts.width();
        } else {
          return this.opts.width;
        }
      }
      ;
      var width = resolveContainerWidth.call(this);
      if (width !== null) {
        this.container.css('width', width);
      }
    }
  });
  SingleSelect2 = clazz(AbstractSelect2, {
    createContainer: function () {
      var container = $(document.createElement('div')).attr({ 'class': 'select2-container' }).html([
          '<a href=\'javascript:void(0)\' onclick=\'return false;\' class=\'select2-choice\' tabindex=\'-1\'>',
          '   <span class=\'select2-chosen\'>&nbsp;</span><abbr class=\'select2-search-choice-close\'></abbr>',
          '   <span class=\'select2-arrow\'><b></b></span>',
          '</a>',
          '<input class=\'select2-focusser select2-offscreen\' type=\'text\'/>',
          '<div class=\'select2-drop select2-display-none\'>',
          '   <div class=\'select2-search\'>',
          '       <input type=\'text\' autocomplete=\'off\' autocorrect=\'off\' autocapitalize=\'off\' spellcheck=\'false\' class=\'select2-input\'/>',
          '   </div>',
          '   <ul class=\'select2-results\'>',
          '   </ul>',
          '</div>'
        ].join(''));
      return container;
    },
    enableInterface: function () {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.focusser.prop('disabled', !this.isInterfaceEnabled());
      }
    },
    opening: function () {
      var el, range, len;
      if (this.opts.minimumResultsForSearch >= 0) {
        this.showSearch(true);
      }
      this.parent.opening.apply(this, arguments);
      if (this.showSearchInput !== false) {
        this.search.val(this.focusser.val());
      }
      this.search.focus();
      el = this.search.get(0);
      if (el.createTextRange) {
        range = el.createTextRange();
        range.collapse(false);
        range.select();
      } else if (el.setSelectionRange) {
        len = this.search.val().length;
        el.setSelectionRange(len, len);
      }
      if (this.search.val() === '') {
        if (this.nextSearchTerm != undefined) {
          this.search.val(this.nextSearchTerm);
          this.search.select();
        }
      }
      this.focusser.prop('disabled', true).val('');
      this.updateResults(true);
      this.opts.element.trigger($.Event('select2-open'));
    },
    close: function (params) {
      if (!this.opened())
        return;
      this.parent.close.apply(this, arguments);
      params = params || { focus: true };
      this.focusser.removeAttr('disabled');
      if (params.focus) {
        this.focusser.focus();
      }
    },
    focus: function () {
      if (this.opened()) {
        this.close();
      } else {
        this.focusser.removeAttr('disabled');
        this.focusser.focus();
      }
    },
    isFocused: function () {
      return this.container.hasClass('select2-container-active');
    },
    cancel: function () {
      this.parent.cancel.apply(this, arguments);
      this.focusser.removeAttr('disabled');
      this.focusser.focus();
    },
    destroy: function () {
      $('label[for=\'' + this.focusser.attr('id') + '\']').attr('for', this.opts.element.attr('id'));
      this.parent.destroy.apply(this, arguments);
    },
    initContainer: function () {
      var selection, container = this.container, dropdown = this.dropdown;
      if (this.opts.minimumResultsForSearch < 0) {
        this.showSearch(false);
      } else {
        this.showSearch(true);
      }
      this.selection = selection = container.find('.select2-choice');
      this.focusser = container.find('.select2-focusser');
      this.focusser.attr('id', 's2id_autogen' + nextUid());
      $('label[for=\'' + this.opts.element.attr('id') + '\']').attr('for', this.focusser.attr('id'));
      this.focusser.attr('tabindex', this.elementTabIndex);
      this.search.on('keydown', this.bind(function (e) {
        if (!this.isInterfaceEnabled())
          return;
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
          return;
        }
        switch (e.which) {
        case KEY.UP:
        case KEY.DOWN:
          this.moveHighlight(e.which === KEY.UP ? -1 : 1);
          killEvent(e);
          return;
        case KEY.ENTER:
          this.selectHighlighted();
          killEvent(e);
          return;
        case KEY.TAB:
          this.selectHighlighted({ noFocus: true });
          return;
        case KEY.ESC:
          this.cancel(e);
          killEvent(e);
          return;
        }
      }));
      this.search.on('blur', this.bind(function (e) {
        if (document.activeElement === this.body().get(0)) {
          window.setTimeout(this.bind(function () {
            this.search.focus();
          }), 0);
        }
      }));
      this.focusser.on('keydown', this.bind(function (e) {
        if (!this.isInterfaceEnabled())
          return;
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
          return;
        }
        if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
          killEvent(e);
          return;
        }
        if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER && this.opts.openOnEnter) {
          if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey)
            return;
          this.open();
          killEvent(e);
          return;
        }
        if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
          if (this.opts.allowClear) {
            this.clear();
          }
          killEvent(e);
          return;
        }
      }));
      installKeyUpChangeEvent(this.focusser);
      this.focusser.on('keyup-change input', this.bind(function (e) {
        if (this.opts.minimumResultsForSearch >= 0) {
          e.stopPropagation();
          if (this.opened())
            return;
          this.open();
        }
      }));
      selection.on('mousedown', 'abbr', this.bind(function (e) {
        if (!this.isInterfaceEnabled())
          return;
        this.clear();
        killEventImmediately(e);
        this.close();
        this.selection.focus();
      }));
      selection.on('mousedown', this.bind(function (e) {
        if (!this.container.hasClass('select2-container-active')) {
          this.opts.element.trigger($.Event('select2-focus'));
        }
        if (this.opened()) {
          this.close();
        } else if (this.isInterfaceEnabled()) {
          this.open();
        }
        killEvent(e);
      }));
      dropdown.on('mousedown', this.bind(function () {
        this.search.focus();
      }));
      selection.on('focus', this.bind(function (e) {
        killEvent(e);
      }));
      this.focusser.on('focus', this.bind(function () {
        if (!this.container.hasClass('select2-container-active')) {
          this.opts.element.trigger($.Event('select2-focus'));
        }
        this.container.addClass('select2-container-active');
      })).on('blur', this.bind(function () {
        if (!this.opened()) {
          this.container.removeClass('select2-container-active');
          this.opts.element.trigger($.Event('select2-blur'));
        }
      }));
      this.search.on('focus', this.bind(function () {
        if (!this.container.hasClass('select2-container-active')) {
          this.opts.element.trigger($.Event('select2-focus'));
        }
        this.container.addClass('select2-container-active');
      }));
      this.initContainerWidth();
      this.opts.element.addClass('select2-offscreen');
      this.setPlaceholder();
    },
    clear: function (triggerChange) {
      var data = this.selection.data('select2-data');
      if (data) {
        var evt = $.Event('select2-clearing');
        this.opts.element.trigger(evt);
        if (evt.isDefaultPrevented()) {
          return;
        }
        var placeholderOption = this.getPlaceholderOption();
        this.opts.element.val(placeholderOption ? placeholderOption.val() : '');
        this.selection.find('.select2-chosen').empty();
        this.selection.removeData('select2-data');
        this.setPlaceholder();
        if (triggerChange !== false) {
          this.opts.element.trigger({
            type: 'select2-removed',
            val: this.id(data),
            choice: data
          });
          this.triggerChange({ removed: data });
        }
      }
    },
    initSelection: function () {
      var selected;
      if (this.isPlaceholderOptionSelected()) {
        this.updateSelection(null);
        this.close();
        this.setPlaceholder();
      } else {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function (selected) {
          if (selected !== undefined && selected !== null) {
            self.updateSelection(selected);
            self.close();
            self.setPlaceholder();
          }
        });
      }
    },
    isPlaceholderOptionSelected: function () {
      var placeholderOption;
      if (!this.getPlaceholder())
        return false;
      return (placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop('selected') || this.opts.element.val() === '' || this.opts.element.val() === undefined || this.opts.element.val() === null;
    },
    prepareOpts: function () {
      var opts = this.parent.prepareOpts.apply(this, arguments), self = this;
      if (opts.element.get(0).tagName.toLowerCase() === 'select') {
        opts.initSelection = function (element, callback) {
          var selected = element.find('option').filter(function () {
              return this.selected;
            });
          callback(self.optionToData(selected));
        };
      } else if ('data' in opts) {
        opts.initSelection = opts.initSelection || function (element, callback) {
          var id = element.val();
          var match = null;
          opts.query({
            matcher: function (term, text, el) {
              var is_match = equal(id, opts.id(el));
              if (is_match) {
                match = el;
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function () {
              callback(match);
            }
          });
        };
      }
      return opts;
    },
    getPlaceholder: function () {
      if (this.select) {
        if (this.getPlaceholderOption() === undefined) {
          return undefined;
        }
      }
      return this.parent.getPlaceholder.apply(this, arguments);
    },
    setPlaceholder: function () {
      var placeholder = this.getPlaceholder();
      if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {
        if (this.select && this.getPlaceholderOption() === undefined)
          return;
        this.selection.find('.select2-chosen').html(this.opts.escapeMarkup(placeholder));
        this.selection.addClass('select2-default');
        this.container.removeClass('select2-allowclear');
      }
    },
    postprocessResults: function (data, initial, noHighlightUpdate) {
      var selected = 0, self = this, showSearchInput = true;
      this.findHighlightableChoices().each2(function (i, elm) {
        if (equal(self.id(elm.data('select2-data')), self.opts.element.val())) {
          selected = i;
          return false;
        }
      });
      if (noHighlightUpdate !== false) {
        if (initial === true && selected >= 0) {
          this.highlight(selected);
        } else {
          this.highlight(0);
        }
      }
      if (initial === true) {
        var min = this.opts.minimumResultsForSearch;
        if (min >= 0) {
          this.showSearch(countResults(data.results) >= min);
        }
      }
    },
    showSearch: function (showSearchInput) {
      if (this.showSearchInput === showSearchInput)
        return;
      this.showSearchInput = showSearchInput;
      this.dropdown.find('.select2-search').toggleClass('select2-search-hidden', !showSearchInput);
      this.dropdown.find('.select2-search').toggleClass('select2-offscreen', !showSearchInput);
      $(this.dropdown, this.container).toggleClass('select2-with-searchbox', showSearchInput);
    },
    onSelect: function (data, options) {
      if (!this.triggerSelect(data)) {
        return;
      }
      var old = this.opts.element.val(), oldData = this.data();
      this.opts.element.val(this.id(data));
      this.updateSelection(data);
      this.opts.element.trigger({
        type: 'select2-selected',
        val: this.id(data),
        choice: data
      });
      this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
      this.close();
      if (!options || !options.noFocus)
        this.focusser.focus();
      if (!equal(old, this.id(data))) {
        this.triggerChange({
          added: data,
          removed: oldData
        });
      }
    },
    updateSelection: function (data) {
      var container = this.selection.find('.select2-chosen'), formatted, cssClass;
      this.selection.data('select2-data', data);
      container.empty();
      if (data !== null) {
        formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
      }
      if (formatted !== undefined) {
        container.append(formatted);
      }
      cssClass = this.opts.formatSelectionCssClass(data, container);
      if (cssClass !== undefined) {
        container.addClass(cssClass);
      }
      this.selection.removeClass('select2-default');
      if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
        this.container.addClass('select2-allowclear');
      }
    },
    val: function () {
      var val, triggerChange = false, data = null, self = this, oldData = this.data();
      if (arguments.length === 0) {
        return this.opts.element.val();
      }
      val = arguments[0];
      if (arguments.length > 1) {
        triggerChange = arguments[1];
      }
      if (this.select) {
        this.select.val(val).find('option').filter(function () {
          return this.selected;
        }).each2(function (i, elm) {
          data = self.optionToData(elm);
          return false;
        });
        this.updateSelection(data);
        this.setPlaceholder();
        if (triggerChange) {
          this.triggerChange({
            added: data,
            removed: oldData
          });
        }
      } else {
        if (!val && val !== 0) {
          this.clear(triggerChange);
          return;
        }
        if (this.opts.initSelection === undefined) {
          throw new Error('cannot call val() if initSelection() is not defined');
        }
        this.opts.element.val(val);
        this.opts.initSelection(this.opts.element, function (data) {
          self.opts.element.val(!data ? '' : self.id(data));
          self.updateSelection(data);
          self.setPlaceholder();
          if (triggerChange) {
            self.triggerChange({
              added: data,
              removed: oldData
            });
          }
        });
      }
    },
    clearSearch: function () {
      this.search.val('');
      this.focusser.val('');
    },
    data: function (value) {
      var data, triggerChange = false;
      if (arguments.length === 0) {
        data = this.selection.data('select2-data');
        if (data == undefined)
          data = null;
        return data;
      } else {
        if (arguments.length > 1) {
          triggerChange = arguments[1];
        }
        if (!value) {
          this.clear(triggerChange);
        } else {
          data = this.data();
          this.opts.element.val(!value ? '' : this.id(value));
          this.updateSelection(value);
          if (triggerChange) {
            this.triggerChange({
              added: value,
              removed: data
            });
          }
        }
      }
    }
  });
  MultiSelect2 = clazz(AbstractSelect2, {
    createContainer: function () {
      var container = $(document.createElement('div')).attr({ 'class': 'select2-container select2-container-multi' }).html([
          '<ul class=\'select2-choices\'>',
          '  <li class=\'select2-search-field\'>',
          '    <input type=\'text\' autocomplete=\'off\' autocorrect=\'off\' autocapitalize=\'off\' spellcheck=\'false\' class=\'select2-input\'>',
          '  </li>',
          '</ul>',
          '<div class=\'select2-drop select2-drop-multi select2-display-none\'>',
          '   <ul class=\'select2-results\'>',
          '   </ul>',
          '</div>'
        ].join(''));
      return container;
    },
    prepareOpts: function () {
      var opts = this.parent.prepareOpts.apply(this, arguments), self = this;
      if (opts.element.get(0).tagName.toLowerCase() === 'select') {
        opts.initSelection = function (element, callback) {
          var data = [];
          element.find('option').filter(function () {
            return this.selected;
          }).each2(function (i, elm) {
            data.push(self.optionToData(elm));
          });
          callback(data);
        };
      } else if ('data' in opts) {
        opts.initSelection = opts.initSelection || function (element, callback) {
          var ids = splitVal(element.val(), opts.separator);
          var matches = [];
          opts.query({
            matcher: function (term, text, el) {
              var is_match = $.grep(ids, function (id) {
                  return equal(id, opts.id(el));
                }).length;
              if (is_match) {
                matches.push(el);
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function () {
              var ordered = [];
              for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];
                  if (equal(id, opts.id(match))) {
                    ordered.push(match);
                    matches.splice(j, 1);
                    break;
                  }
                }
              }
              callback(ordered);
            }
          });
        };
      }
      return opts;
    },
    selectChoice: function (choice) {
      var selected = this.container.find('.select2-search-choice-focus');
      if (selected.length && choice && choice[0] == selected[0]) {
      } else {
        if (selected.length) {
          this.opts.element.trigger('choice-deselected', selected);
        }
        selected.removeClass('select2-search-choice-focus');
        if (choice && choice.length) {
          this.close();
          choice.addClass('select2-search-choice-focus');
          this.opts.element.trigger('choice-selected', choice);
        }
      }
    },
    destroy: function () {
      $('label[for=\'' + this.search.attr('id') + '\']').attr('for', this.opts.element.attr('id'));
      this.parent.destroy.apply(this, arguments);
    },
    initContainer: function () {
      var selector = '.select2-choices', selection;
      this.searchContainer = this.container.find('.select2-search-field');
      this.selection = selection = this.container.find(selector);
      var _this = this;
      this.selection.on('click', '.select2-search-choice:not(.select2-locked)', function (e) {
        _this.search[0].focus();
        _this.selectChoice($(this));
      });
      this.search.attr('id', 's2id_autogen' + nextUid());
      $('label[for=\'' + this.opts.element.attr('id') + '\']').attr('for', this.search.attr('id'));
      this.search.on('input paste', this.bind(function () {
        if (!this.isInterfaceEnabled())
          return;
        if (!this.opened()) {
          this.open();
        }
      }));
      this.search.attr('tabindex', this.elementTabIndex);
      this.keydowns = 0;
      this.search.on('keydown', this.bind(function (e) {
        if (!this.isInterfaceEnabled())
          return;
        ++this.keydowns;
        var selected = selection.find('.select2-search-choice-focus');
        var prev = selected.prev('.select2-search-choice:not(.select2-locked)');
        var next = selected.next('.select2-search-choice:not(.select2-locked)');
        var pos = getCursorInfo(this.search);
        if (selected.length && (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
          var selectedChoice = selected;
          if (e.which == KEY.LEFT && prev.length) {
            selectedChoice = prev;
          } else if (e.which == KEY.RIGHT) {
            selectedChoice = next.length ? next : null;
          } else if (e.which === KEY.BACKSPACE) {
            this.unselect(selected.first());
            this.search.width(10);
            selectedChoice = prev.length ? prev : next;
          } else if (e.which == KEY.DELETE) {
            this.unselect(selected.first());
            this.search.width(10);
            selectedChoice = next.length ? next : null;
          } else if (e.which == KEY.ENTER) {
            selectedChoice = null;
          }
          this.selectChoice(selectedChoice);
          killEvent(e);
          if (!selectedChoice || !selectedChoice.length) {
            this.open();
          }
          return;
        } else if ((e.which === KEY.BACKSPACE && this.keydowns == 1 || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {
          this.selectChoice(selection.find('.select2-search-choice:not(.select2-locked)').last());
          killEvent(e);
          return;
        } else {
          this.selectChoice(null);
        }
        if (this.opened()) {
          switch (e.which) {
          case KEY.UP:
          case KEY.DOWN:
            this.moveHighlight(e.which === KEY.UP ? -1 : 1);
            killEvent(e);
            return;
          case KEY.ENTER:
            this.selectHighlighted();
            killEvent(e);
            return;
          case KEY.TAB:
            this.selectHighlighted({ noFocus: true });
            this.close();
            return;
          case KEY.ESC:
            this.cancel(e);
            killEvent(e);
            return;
          }
        }
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
          return;
        }
        if (e.which === KEY.ENTER) {
          if (this.opts.openOnEnter === false) {
            return;
          } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
            return;
          }
        }
        this.open();
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
        }
        if (e.which === KEY.ENTER) {
          killEvent(e);
        }
      }));
      this.search.on('keyup', this.bind(function (e) {
        this.keydowns = 0;
        this.resizeSearch();
      }));
      this.search.on('blur', this.bind(function (e) {
        this.container.removeClass('select2-container-active');
        this.search.removeClass('select2-focused');
        this.selectChoice(null);
        if (!this.opened())
          this.clearSearch();
        e.stopImmediatePropagation();
        this.opts.element.trigger($.Event('select2-blur'));
      }));
      this.container.on('click', selector, this.bind(function (e) {
        if (!this.isInterfaceEnabled())
          return;
        if ($(e.target).closest('.select2-search-choice').length > 0) {
          return;
        }
        this.selectChoice(null);
        this.clearPlaceholder();
        if (!this.container.hasClass('select2-container-active')) {
          this.opts.element.trigger($.Event('select2-focus'));
        }
        this.open();
        this.focusSearch();
        e.preventDefault();
      }));
      this.container.on('focus', selector, this.bind(function () {
        if (!this.isInterfaceEnabled())
          return;
        if (!this.container.hasClass('select2-container-active')) {
          this.opts.element.trigger($.Event('select2-focus'));
        }
        this.container.addClass('select2-container-active');
        this.dropdown.addClass('select2-drop-active');
        this.clearPlaceholder();
      }));
      this.initContainerWidth();
      this.opts.element.addClass('select2-offscreen');
      this.clearSearch();
    },
    enableInterface: function () {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.search.prop('disabled', !this.isInterfaceEnabled());
      }
    },
    initSelection: function () {
      var data;
      if (this.opts.element.val() === '' && this.opts.element.text() === '') {
        this.updateSelection([]);
        this.close();
        this.clearSearch();
      }
      if (this.select || this.opts.element.val() !== '') {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function (data) {
          if (data !== undefined && data !== null) {
            self.updateSelection(data);
            self.close();
            self.clearSearch();
          }
        });
      }
    },
    clearSearch: function () {
      var placeholder = this.getPlaceholder(), maxWidth = this.getMaxSearchWidth();
      if (placeholder !== undefined && this.getVal().length === 0 && this.search.hasClass('select2-focused') === false) {
        this.search.val(placeholder).addClass('select2-default');
        this.search.width(maxWidth > 0 ? maxWidth : this.container.css('width'));
      } else {
        this.search.val('').width(10);
      }
    },
    clearPlaceholder: function () {
      if (this.search.hasClass('select2-default')) {
        this.search.val('').removeClass('select2-default');
      }
    },
    opening: function () {
      this.clearPlaceholder();
      this.resizeSearch();
      this.parent.opening.apply(this, arguments);
      this.focusSearch();
      this.updateResults(true);
      this.search.focus();
      this.opts.element.trigger($.Event('select2-open'));
    },
    close: function () {
      if (!this.opened())
        return;
      this.parent.close.apply(this, arguments);
    },
    focus: function () {
      this.close();
      this.search.focus();
    },
    isFocused: function () {
      return this.search.hasClass('select2-focused');
    },
    updateSelection: function (data) {
      var ids = [], filtered = [], self = this;
      $(data).each(function () {
        if (indexOf(self.id(this), ids) < 0) {
          ids.push(self.id(this));
          filtered.push(this);
        }
      });
      data = filtered;
      this.selection.find('.select2-search-choice').remove();
      $(data).each(function () {
        self.addSelectedChoice(this);
      });
      self.postprocessResults();
    },
    tokenize: function () {
      var input = this.search.val();
      input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
      if (input != null && input != undefined) {
        this.search.val(input);
        if (input.length > 0) {
          this.open();
        }
      }
    },
    onSelect: function (data, options) {
      if (!this.triggerSelect(data)) {
        return;
      }
      this.addSelectedChoice(data);
      this.opts.element.trigger({
        type: 'selected',
        val: this.id(data),
        choice: data
      });
      if (this.select || !this.opts.closeOnSelect)
        this.postprocessResults(data, false, this.opts.closeOnSelect === true);
      if (this.opts.closeOnSelect) {
        this.close();
        this.search.width(10);
      } else {
        if (this.countSelectableResults() > 0) {
          this.search.width(10);
          this.resizeSearch();
          if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
            this.updateResults(true);
          }
          this.positionDropdown();
        } else {
          this.close();
          this.search.width(10);
        }
      }
      this.triggerChange({ added: data });
      if (!options || !options.noFocus)
        this.focusSearch();
    },
    cancel: function () {
      this.close();
      this.focusSearch();
    },
    addSelectedChoice: function (data) {
      var enableChoice = !data.locked, enabledItem = $('<li class=\'select2-search-choice\'>' + '    <div></div>' + '    <a href=\'#\' onclick=\'return false;\' class=\'select2-search-choice-close\' tabindex=\'-1\'></a>' + '</li>'), disabledItem = $('<li class=\'select2-search-choice select2-locked\'>' + '<div></div>' + '</li>');
      var choice = enableChoice ? enabledItem : disabledItem, id = this.id(data), val = this.getVal(), formatted, cssClass;
      formatted = this.opts.formatSelection(data, choice.find('div'), this.opts.escapeMarkup);
      if (formatted != undefined) {
        choice.find('div').replaceWith('<div>' + formatted + '</div>');
      }
      cssClass = this.opts.formatSelectionCssClass(data, choice.find('div'));
      if (cssClass != undefined) {
        choice.addClass(cssClass);
      }
      if (enableChoice) {
        choice.find('.select2-search-choice-close').on('mousedown', killEvent).on('click dblclick', this.bind(function (e) {
          if (!this.isInterfaceEnabled())
            return;
          $(e.target).closest('.select2-search-choice').fadeOut('fast', this.bind(function () {
            this.unselect($(e.target));
            this.selection.find('.select2-search-choice-focus').removeClass('select2-search-choice-focus');
            this.close();
            this.focusSearch();
          })).dequeue();
          killEvent(e);
        })).on('focus', this.bind(function () {
          if (!this.isInterfaceEnabled())
            return;
          this.container.addClass('select2-container-active');
          this.dropdown.addClass('select2-drop-active');
        }));
      }
      choice.data('select2-data', data);
      choice.insertBefore(this.searchContainer);
      val.push(id);
      this.setVal(val);
    },
    unselect: function (selected) {
      var val = this.getVal(), data, index;
      selected = selected.closest('.select2-search-choice');
      if (selected.length === 0) {
        throw 'Invalid argument: ' + selected + '. Must be .select2-search-choice';
      }
      data = selected.data('select2-data');
      if (!data) {
        return;
      }
      while ((index = indexOf(this.id(data), val)) >= 0) {
        val.splice(index, 1);
        this.setVal(val);
        if (this.select)
          this.postprocessResults();
      }
      var evt = $.Event('select2-removing');
      evt.val = this.id(data);
      evt.choice = data;
      this.opts.element.trigger(evt);
      if (evt.isDefaultPrevented()) {
        return;
      }
      selected.remove();
      this.opts.element.trigger({
        type: 'select2-removed',
        val: this.id(data),
        choice: data
      });
      this.triggerChange({ removed: data });
    },
    postprocessResults: function (data, initial, noHighlightUpdate) {
      var val = this.getVal(), choices = this.results.find('.select2-result'), compound = this.results.find('.select2-result-with-children'), self = this;
      choices.each2(function (i, choice) {
        var id = self.id(choice.data('select2-data'));
        if (indexOf(id, val) >= 0) {
          choice.addClass('select2-selected');
          choice.find('.select2-result-selectable').addClass('select2-selected');
        }
      });
      compound.each2(function (i, choice) {
        if (!choice.is('.select2-result-selectable') && choice.find('.select2-result-selectable:not(.select2-selected)').length === 0) {
          choice.addClass('select2-selected');
        }
      });
      if (this.highlight() == -1 && noHighlightUpdate !== false) {
        self.highlight(0);
      }
      if (!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0) {
        if (!data || data && !data.more && this.results.find('.select2-no-results').length === 0) {
          if (checkFormatter(self.opts.formatNoMatches, 'formatNoMatches')) {
            this.results.append('<li class=\'select2-no-results\'>' + self.opts.formatNoMatches(self.search.val()) + '</li>');
          }
        }
      }
    },
    getMaxSearchWidth: function () {
      return this.selection.width() - getSideBorderPadding(this.search);
    },
    resizeSearch: function () {
      var minimumWidth, left, maxWidth, containerLeft, searchWidth, sideBorderPadding = getSideBorderPadding(this.search);
      minimumWidth = measureTextWidth(this.search) + 10;
      left = this.search.offset().left;
      maxWidth = this.selection.width();
      containerLeft = this.selection.offset().left;
      searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
      if (searchWidth < minimumWidth) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth < 40) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth <= 0) {
        searchWidth = minimumWidth;
      }
      this.search.width(Math.floor(searchWidth));
    },
    getVal: function () {
      var val;
      if (this.select) {
        val = this.select.val();
        return val === null ? [] : val;
      } else {
        val = this.opts.element.val();
        return splitVal(val, this.opts.separator);
      }
    },
    setVal: function (val) {
      var unique;
      if (this.select) {
        this.select.val(val);
      } else {
        unique = [];
        $(val).each(function () {
          if (indexOf(this, unique) < 0)
            unique.push(this);
        });
        this.opts.element.val(unique.length === 0 ? '' : unique.join(this.opts.separator));
      }
    },
    buildChangeDetails: function (old, current) {
      var current = current.slice(0), old = old.slice(0);
      for (var i = 0; i < current.length; i++) {
        for (var j = 0; j < old.length; j++) {
          if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
            current.splice(i, 1);
            if (i > 0) {
              i--;
            }
            old.splice(j, 1);
            j--;
          }
        }
      }
      return {
        added: current,
        removed: old
      };
    },
    val: function (val, triggerChange) {
      var oldData, self = this;
      if (arguments.length === 0) {
        return this.getVal();
      }
      oldData = this.data();
      if (!oldData.length)
        oldData = [];
      if (!val && val !== 0) {
        this.opts.element.val('');
        this.updateSelection([]);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange({
            added: this.data(),
            removed: oldData
          });
        }
        return;
      }
      this.setVal(val);
      if (this.select) {
        this.opts.initSelection(this.select, this.bind(this.updateSelection));
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(oldData, this.data()));
        }
      } else {
        if (this.opts.initSelection === undefined) {
          throw new Error('val() cannot be called if initSelection() is not defined');
        }
        this.opts.initSelection(this.opts.element, function (data) {
          var ids = $.map(data, self.id);
          self.setVal(ids);
          self.updateSelection(data);
          self.clearSearch();
          if (triggerChange) {
            self.triggerChange(self.buildChangeDetails(oldData, self.data()));
          }
        });
      }
      this.clearSearch();
    },
    onSortStart: function () {
      if (this.select) {
        throw new Error('Sorting of elements is not supported when attached to <select>. Attach to <input type=\'hidden\'/> instead.');
      }
      this.search.width(0);
      this.searchContainer.hide();
    },
    onSortEnd: function () {
      var val = [], self = this;
      this.searchContainer.show();
      this.searchContainer.appendTo(this.searchContainer.parent());
      this.resizeSearch();
      this.selection.find('.select2-search-choice').each(function () {
        val.push(self.opts.id($(this).data('select2-data')));
      });
      this.setVal(val);
      this.triggerChange();
    },
    data: function (values, triggerChange) {
      var self = this, ids, old;
      if (arguments.length === 0) {
        return this.selection.find('.select2-search-choice').map(function () {
          return $(this).data('select2-data');
        }).get();
      } else {
        old = this.data();
        if (!values) {
          values = [];
        }
        ids = $.map(values, function (e) {
          return self.opts.id(e);
        });
        this.setVal(ids);
        this.updateSelection(values);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(old, this.data()));
        }
      }
    }
  });
  $.fn.select2 = function () {
    var args = Array.prototype.slice.call(arguments, 0), opts, select2, method, value, multiple, allowedMethods = [
        'val',
        'destroy',
        'opened',
        'open',
        'close',
        'focus',
        'isFocused',
        'container',
        'dropdown',
        'onSortStart',
        'onSortEnd',
        'enable',
        'disable',
        'readonly',
        'positionDropdown',
        'data',
        'search'
      ], valueMethods = [
        'opened',
        'isFocused',
        'container',
        'dropdown'
      ], propertyMethods = [
        'val',
        'data'
      ], methodsMap = { search: 'externalSearch' };
    this.each(function () {
      if (args.length === 0 || typeof args[0] === 'object') {
        opts = args.length === 0 ? {} : $.extend({}, args[0]);
        opts.element = $(this);
        if (opts.element.get(0).tagName.toLowerCase() === 'select') {
          multiple = opts.element.prop('multiple');
        } else {
          multiple = opts.multiple || false;
          if ('tags' in opts) {
            opts.multiple = multiple = true;
          }
        }
        select2 = multiple ? new MultiSelect2() : new SingleSelect2();
        select2.init(opts);
      } else if (typeof args[0] === 'string') {
        if (indexOf(args[0], allowedMethods) < 0) {
          throw 'Unknown method: ' + args[0];
        }
        value = undefined;
        select2 = $(this).data('select2');
        if (select2 === undefined)
          return;
        method = args[0];
        if (method === 'container') {
          value = select2.container;
        } else if (method === 'dropdown') {
          value = select2.dropdown;
        } else {
          if (methodsMap[method])
            method = methodsMap[method];
          value = select2[method].apply(select2, args.slice(1));
        }
        if (indexOf(args[0], valueMethods) >= 0 || indexOf(args[0], propertyMethods) && args.length == 1) {
          return false;
        }
      } else {
        throw 'Invalid arguments to select2 plugin: ' + args;
      }
    });
    return value === undefined ? this : value;
  };
  $.fn.select2.defaults = {
    width: 'copy',
    loadMorePadding: 0,
    closeOnSelect: true,
    openOnEnter: true,
    containerCss: {},
    dropdownCss: {},
    containerCssClass: '',
    dropdownCssClass: '',
    formatResult: function (result, container, query, escapeMarkup) {
      var markup = [];
      markMatch(result.text, query.term, markup, escapeMarkup);
      return markup.join('');
    },
    formatSelection: function (data, container, escapeMarkup) {
      return data ? escapeMarkup(data.text) : undefined;
    },
    sortResults: function (results, container, query) {
      return results;
    },
    formatResultCssClass: function (data) {
      return undefined;
    },
    formatSelectionCssClass: function (data, container) {
      return undefined;
    },
    formatNoMatches: function () {
      return 'No matches found';
    },
    formatInputTooShort: function (input, min) {
      var n = min - input.length;
      return 'Please enter ' + n + ' more character' + (n == 1 ? '' : 's');
    },
    formatInputTooLong: function (input, max) {
      var n = input.length - max;
      return 'Please delete ' + n + ' character' + (n == 1 ? '' : 's');
    },
    formatSelectionTooBig: function (limit) {
      return 'You can only select ' + limit + ' item' + (limit == 1 ? '' : 's');
    },
    formatLoadMore: function (pageNumber) {
      return 'Loading more results...';
    },
    formatSearching: function () {
      return 'Searching...';
    },
    minimumResultsForSearch: 0,
    minimumInputLength: 0,
    maximumInputLength: null,
    maximumSelectionSize: 0,
    id: function (e) {
      return e.id;
    },
    matcher: function (term, text) {
      return stripDiacritics('' + text).toUpperCase().indexOf(stripDiacritics('' + term).toUpperCase()) >= 0;
    },
    separator: ',',
    tokenSeparators: [],
    tokenizer: defaultTokenizer,
    escapeMarkup: defaultEscapeMarkup,
    blurOnChange: false,
    selectOnBlur: false,
    adaptContainerCssClass: function (c) {
      return c;
    },
    adaptDropdownCssClass: function (c) {
      return null;
    },
    nextSearchTerm: function (selectedObject, currentSearchTerm) {
      return undefined;
    }
  };
  $.fn.select2.ajaxDefaults = {
    transport: $.ajax,
    params: {
      type: 'GET',
      cache: false,
      dataType: 'json'
    }
  };
  window.Select2 = {
    query: {
      ajax: ajax,
      local: local,
      tags: tags
    },
    util: {
      debounce: debounce,
      markMatch: markMatch,
      escapeMarkup: defaultEscapeMarkup,
      stripDiacritics: stripDiacritics
    },
    'class': {
      'abstract': AbstractSelect2,
      'single': SingleSelect2,
      'multi': MultiSelect2
    }
  };
}(jQuery));
angular.module('ui.bootstrap', [
  'ui.bootstrap.tpls',
  'ui.bootstrap.transition',
  'ui.bootstrap.collapse',
  'ui.bootstrap.accordion',
  'ui.bootstrap.alert',
  'ui.bootstrap.bindHtml',
  'ui.bootstrap.buttons',
  'ui.bootstrap.carousel',
  'ui.bootstrap.position',
  'ui.bootstrap.datepicker',
  'ui.bootstrap.dropdownToggle',
  'ui.bootstrap.modal',
  'ui.bootstrap.pagination',
  'ui.bootstrap.tooltip',
  'ui.bootstrap.popover',
  'ui.bootstrap.progressbar',
  'ui.bootstrap.rating',
  'ui.bootstrap.tabs',
  'ui.bootstrap.timepicker',
  'ui.bootstrap.typeahead'
]);
angular.module('ui.bootstrap.tpls', [
  'template/accordion/accordion-group.html',
  'template/accordion/accordion.html',
  'template/alert/alert.html',
  'template/carousel/carousel.html',
  'template/carousel/slide.html',
  'template/datepicker/datepicker.html',
  'template/datepicker/popup.html',
  'template/modal/backdrop.html',
  'template/modal/window.html',
  'template/pagination/pager.html',
  'template/pagination/pagination.html',
  'template/tooltip/tooltip-html-unsafe-popup.html',
  'template/tooltip/tooltip-popup.html',
  'template/popover/popover.html',
  'template/progressbar/bar.html',
  'template/progressbar/progress.html',
  'template/progressbar/progressbar.html',
  'template/rating/rating.html',
  'template/tabs/tab.html',
  'template/tabs/tabset.html',
  'template/timepicker/timepicker.html',
  'template/typeahead/typeahead-match.html',
  'template/typeahead/typeahead-popup.html'
]);
angular.module('ui.bootstrap.transition', []).factory('$transition', [
  '$q',
  '$timeout',
  '$rootScope',
  function ($q, $timeout, $rootScope) {
    var $transition = function (element, trigger, options) {
      options = options || {};
      var deferred = $q.defer();
      var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];
      var transitionEndHandler = function (event) {
        $rootScope.$apply(function () {
          element.unbind(endEventName, transitionEndHandler);
          deferred.resolve(element);
        });
      };
      if (endEventName) {
        element.bind(endEventName, transitionEndHandler);
      }
      $timeout(function () {
        if (angular.isString(trigger)) {
          element.addClass(trigger);
        } else if (angular.isFunction(trigger)) {
          trigger(element);
        } else if (angular.isObject(trigger)) {
          element.css(trigger);
        }
        if (!endEventName) {
          deferred.resolve(element);
        }
      });
      deferred.promise.cancel = function () {
        if (endEventName) {
          element.unbind(endEventName, transitionEndHandler);
        }
        deferred.reject('Transition cancelled');
      };
      return deferred.promise;
    };
    var transElement = document.createElement('trans');
    var transitionEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'transition': 'transitionend'
      };
    var animationEndEventNames = {
        'WebkitTransition': 'webkitAnimationEnd',
        'MozTransition': 'animationend',
        'OTransition': 'oAnimationEnd',
        'transition': 'animationend'
      };
    function findEndEventName(endEventNames) {
      for (var name in endEventNames) {
        if (transElement.style[name] !== undefined) {
          return endEventNames[name];
        }
      }
    }
    $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
    $transition.animationEndEventName = findEndEventName(animationEndEventNames);
    return $transition;
  }
]);
angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition']).directive('collapse', [
  '$transition',
  function ($transition, $timeout) {
    return {
      link: function (scope, element, attrs) {
        var initialAnimSkip = true;
        var currentTransition;
        function doTransition(change) {
          var newTransition = $transition(element, change);
          if (currentTransition) {
            currentTransition.cancel();
          }
          currentTransition = newTransition;
          newTransition.then(newTransitionDone, newTransitionDone);
          return newTransition;
          function newTransitionDone() {
            if (currentTransition === newTransition) {
              currentTransition = undefined;
            }
          }
        }
        function expand() {
          if (initialAnimSkip) {
            initialAnimSkip = false;
            expandDone();
          } else {
            element.removeClass('collapse').addClass('collapsing');
            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);
          }
        }
        function expandDone() {
          element.removeClass('collapsing');
          element.addClass('collapse in');
          element.css({ height: 'auto' });
        }
        function collapse() {
          if (initialAnimSkip) {
            initialAnimSkip = false;
            collapseDone();
            element.css({ height: 0 });
          } else {
            element.css({ height: element[0].scrollHeight + 'px' });
            var x = element[0].offsetWidth;
            element.removeClass('collapse in').addClass('collapsing');
            doTransition({ height: 0 }).then(collapseDone);
          }
        }
        function collapseDone() {
          element.removeClass('collapsing');
          element.addClass('collapse');
        }
        scope.$watch(attrs.collapse, function (shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }
]);
angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('accordionConfig', { closeOthers: true }).controller('AccordionController', [
  '$scope',
  '$attrs',
  'accordionConfig',
  function ($scope, $attrs, accordionConfig) {
    this.groups = [];
    this.closeOthers = function (openGroup) {
      var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
      if (closeOthers) {
        angular.forEach(this.groups, function (group) {
          if (group !== openGroup) {
            group.isOpen = false;
          }
        });
      }
    };
    this.addGroup = function (groupScope) {
      var that = this;
      this.groups.push(groupScope);
      groupScope.$on('$destroy', function (event) {
        that.removeGroup(groupScope);
      });
    };
    this.removeGroup = function (group) {
      var index = this.groups.indexOf(group);
      if (index !== -1) {
        this.groups.splice(this.groups.indexOf(group), 1);
      }
    };
  }
]).directive('accordion', function () {
  return {
    restrict: 'EA',
    controller: 'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
}).directive('accordionGroup', [
  '$parse',
  function ($parse) {
    return {
      require: '^accordion',
      restrict: 'EA',
      transclude: true,
      replace: true,
      templateUrl: 'template/accordion/accordion-group.html',
      scope: { heading: '@' },
      controller: function () {
        this.setHeading = function (element) {
          this.heading = element;
        };
      },
      link: function (scope, element, attrs, accordionCtrl) {
        var getIsOpen, setIsOpen;
        accordionCtrl.addGroup(scope);
        scope.isOpen = false;
        if (attrs.isOpen) {
          getIsOpen = $parse(attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          scope.$parent.$watch(getIsOpen, function (value) {
            scope.isOpen = !!value;
          });
        }
        scope.$watch('isOpen', function (value) {
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
          if (setIsOpen) {
            setIsOpen(scope.$parent, value);
          }
        });
      }
    };
  }
]).directive('accordionHeading', function () {
  return {
    restrict: 'EA',
    transclude: true,
    template: '',
    replace: true,
    require: '^accordionGroup',
    compile: function (element, attr, transclude) {
      return function link(scope, element, attr, accordionGroupCtrl) {
        accordionGroupCtrl.setHeading(transclude(scope, function () {
        }));
      };
    }
  };
}).directive('accordionTransclude', function () {
  return {
    require: '^accordionGroup',
    link: function (scope, element, attr, controller) {
      scope.$watch(function () {
        return controller[attr.accordionTransclude];
      }, function (heading) {
        if (heading) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});
angular.module('ui.bootstrap.alert', []).controller('AlertController', [
  '$scope',
  '$attrs',
  function ($scope, $attrs) {
    $scope.closeable = 'close' in $attrs;
  }
]).directive('alert', function () {
  return {
    restrict: 'EA',
    controller: 'AlertController',
    templateUrl: 'template/alert/alert.html',
    transclude: true,
    replace: true,
    scope: {
      type: '=',
      close: '&'
    }
  };
});
angular.module('ui.bootstrap.bindHtml', []).directive('bindHtmlUnsafe', function () {
  return function (scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
    scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
      element.html(value || '');
    });
  };
});
angular.module('ui.bootstrap.buttons', []).constant('buttonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
}).controller('ButtonsController', [
  'buttonConfig',
  function (buttonConfig) {
    this.activeClass = buttonConfig.activeClass || 'active';
    this.toggleEvent = buttonConfig.toggleEvent || 'click';
  }
]).directive('btnRadio', function () {
  return {
    require: [
      'btnRadio',
      'ngModel'
    ],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };
      element.bind(buttonsCtrl.toggleEvent, function () {
        if (!element.hasClass(buttonsCtrl.activeClass)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
}).directive('btnCheckbox', function () {
  return {
    require: [
      'btnCheckbox',
      'ngModel'
    ],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }
      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }
      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };
      element.bind(buttonsCtrl.toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition']).controller('CarouselController', [
  '$scope',
  '$timeout',
  '$transition',
  '$q',
  function ($scope, $timeout, $transition, $q) {
    var self = this, slides = self.slides = [], currentIndex = -1, currentTimeout, isPlaying;
    self.currentSlide = null;
    var destroyed = false;
    self.select = function (nextSlide, direction) {
      var nextIndex = slides.indexOf(nextSlide);
      if (direction === undefined) {
        direction = nextIndex > currentIndex ? 'next' : 'prev';
      }
      if (nextSlide && nextSlide !== self.currentSlide) {
        if ($scope.$currentTransition) {
          $scope.$currentTransition.cancel();
          $timeout(goNext);
        } else {
          goNext();
        }
      }
      function goNext() {
        if (destroyed) {
          return;
        }
        if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
          nextSlide.$element.addClass(direction);
          var reflow = nextSlide.$element[0].offsetWidth;
          angular.forEach(slides, function (slide) {
            angular.extend(slide, {
              direction: '',
              entering: false,
              leaving: false,
              active: false
            });
          });
          angular.extend(nextSlide, {
            direction: direction,
            active: true,
            entering: true
          });
          angular.extend(self.currentSlide || {}, {
            direction: direction,
            leaving: true
          });
          $scope.$currentTransition = $transition(nextSlide.$element, {});
          (function (next, current) {
            $scope.$currentTransition.then(function () {
              transitionDone(next, current);
            }, function () {
              transitionDone(next, current);
            });
          }(nextSlide, self.currentSlide));
        } else {
          transitionDone(nextSlide, self.currentSlide);
        }
        self.currentSlide = nextSlide;
        currentIndex = nextIndex;
        restartTimer();
      }
      function transitionDone(next, current) {
        angular.extend(next, {
          direction: '',
          active: true,
          leaving: false,
          entering: false
        });
        angular.extend(current || {}, {
          direction: '',
          active: false,
          leaving: false,
          entering: false
        });
        $scope.$currentTransition = null;
      }
    };
    $scope.$on('$destroy', function () {
      destroyed = true;
    });
    self.indexOfSlide = function (slide) {
      return slides.indexOf(slide);
    };
    $scope.next = function () {
      var newIndex = (currentIndex + 1) % slides.length;
      if (!$scope.$currentTransition) {
        return self.select(slides[newIndex], 'next');
      }
    };
    $scope.prev = function () {
      var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;
      if (!$scope.$currentTransition) {
        return self.select(slides[newIndex], 'prev');
      }
    };
    $scope.select = function (slide) {
      self.select(slide);
    };
    $scope.isActive = function (slide) {
      return self.currentSlide === slide;
    };
    $scope.slides = function () {
      return slides;
    };
    $scope.$watch('interval', restartTimer);
    $scope.$on('$destroy', resetTimer);
    function restartTimer() {
      resetTimer();
      var interval = +$scope.interval;
      if (!isNaN(interval) && interval >= 0) {
        currentTimeout = $timeout(timerFn, interval);
      }
    }
    function resetTimer() {
      if (currentTimeout) {
        $timeout.cancel(currentTimeout);
        currentTimeout = null;
      }
    }
    function timerFn() {
      if (isPlaying) {
        $scope.next();
        restartTimer();
      } else {
        $scope.pause();
      }
    }
    $scope.play = function () {
      if (!isPlaying) {
        isPlaying = true;
        restartTimer();
      }
    };
    $scope.pause = function () {
      if (!$scope.noPause) {
        isPlaying = false;
        resetTimer();
      }
    };
    self.addSlide = function (slide, element) {
      slide.$element = element;
      slides.push(slide);
      if (slides.length === 1 || slide.active) {
        self.select(slides[slides.length - 1]);
        if (slides.length == 1) {
          $scope.play();
        }
      } else {
        slide.active = false;
      }
    };
    self.removeSlide = function (slide) {
      var index = slides.indexOf(slide);
      slides.splice(index, 1);
      if (slides.length > 0 && slide.active) {
        if (index >= slides.length) {
          self.select(slides[index - 1]);
        } else {
          self.select(slides[index]);
        }
      } else if (currentIndex > index) {
        currentIndex--;
      }
    };
  }
]).directive('carousel', [function () {
    return {
      restrict: 'EA',
      transclude: true,
      replace: true,
      controller: 'CarouselController',
      require: 'carousel',
      templateUrl: 'template/carousel/carousel.html',
      scope: {
        interval: '=',
        noTransition: '=',
        noPause: '='
      }
    };
  }]).directive('slide', [
  '$parse',
  function ($parse) {
    return {
      require: '^carousel',
      restrict: 'EA',
      transclude: true,
      replace: true,
      templateUrl: 'template/carousel/slide.html',
      scope: {},
      link: function (scope, element, attrs, carouselCtrl) {
        if (attrs.active) {
          var getActive = $parse(attrs.active);
          var setActive = getActive.assign;
          var lastValue = scope.active = getActive(scope.$parent);
          scope.$watch(function parentActiveWatch() {
            var parentActive = getActive(scope.$parent);
            if (parentActive !== scope.active) {
              if (parentActive !== lastValue) {
                lastValue = scope.active = parentActive;
              } else {
                setActive(scope.$parent, parentActive = lastValue = scope.active);
              }
            }
            return parentActive;
          });
        }
        carouselCtrl.addSlide(scope, element);
        scope.$on('$destroy', function () {
          carouselCtrl.removeSlide(scope);
        });
        scope.$watch('active', function (active) {
          if (active) {
            carouselCtrl.select(scope);
          }
        });
      }
    };
  }
]);
angular.module('ui.bootstrap.position', []).factory('$position', [
  '$document',
  '$window',
  function ($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) {
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      return el.style[cssprop];
    }
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static') === 'static';
    }
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };
    return {
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = {
            top: 0,
            left: 0
          };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
        };
      }
    };
  }
]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position']).constant('datepickerConfig', {
  dayFormat: 'dd',
  monthFormat: 'MMMM',
  yearFormat: 'yyyy',
  dayHeaderFormat: 'EEE',
  dayTitleFormat: 'MMMM yyyy',
  monthTitleFormat: 'yyyy',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
}).controller('DatepickerController', [
  '$scope',
  '$attrs',
  'dateFilter',
  'datepickerConfig',
  function ($scope, $attrs, dateFilter, dtConfig) {
    var format = {
        day: getValue($attrs.dayFormat, dtConfig.dayFormat),
        month: getValue($attrs.monthFormat, dtConfig.monthFormat),
        year: getValue($attrs.yearFormat, dtConfig.yearFormat),
        dayHeader: getValue($attrs.dayHeaderFormat, dtConfig.dayHeaderFormat),
        dayTitle: getValue($attrs.dayTitleFormat, dtConfig.dayTitleFormat),
        monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
      }, startingDay = getValue($attrs.startingDay, dtConfig.startingDay), yearRange = getValue($attrs.yearRange, dtConfig.yearRange);
    this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
    this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;
    function getValue(value, defaultValue) {
      return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
    }
    function getDaysInMonth(year, month) {
      return new Date(year, month, 0).getDate();
    }
    function getDates(startDate, n) {
      var dates = new Array(n);
      var current = startDate, i = 0;
      while (i < n) {
        dates[i++] = new Date(current);
        current.setDate(current.getDate() + 1);
      }
      return dates;
    }
    function makeDate(date, format, isSelected, isSecondary) {
      return {
        date: date,
        label: dateFilter(date, format),
        selected: !!isSelected,
        secondary: !!isSecondary
      };
    }
    this.modes = [
      {
        name: 'day',
        getVisibleDates: function (date, selected) {
          var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
          var difference = startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth), numDates = 0;
          if (numDisplayedFromPreviousMonth > 0) {
            firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
            numDates += numDisplayedFromPreviousMonth;
          }
          numDates += getDaysInMonth(year, month + 1);
          numDates += (7 - numDates % 7) % 7;
          var days = getDates(firstDate, numDates), labels = new Array(7);
          for (var i = 0; i < numDates; i++) {
            var dt = new Date(days[i]);
            days[i] = makeDate(dt, format.day, selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear(), dt.getMonth() !== month);
          }
          for (var j = 0; j < 7; j++) {
            labels[j] = dateFilter(days[j].date, format.dayHeader);
          }
          return {
            objects: days,
            title: dateFilter(date, format.dayTitle),
            labels: labels
          };
        },
        compare: function (date1, date2) {
          return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        },
        split: 7,
        step: { months: 1 }
      },
      {
        name: 'month',
        getVisibleDates: function (date, selected) {
          var months = new Array(12), year = date.getFullYear();
          for (var i = 0; i < 12; i++) {
            var dt = new Date(year, i, 1);
            months[i] = makeDate(dt, format.month, selected && selected.getMonth() === i && selected.getFullYear() === year);
          }
          return {
            objects: months,
            title: dateFilter(date, format.monthTitle)
          };
        },
        compare: function (date1, date2) {
          return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
        },
        split: 3,
        step: { years: 1 }
      },
      {
        name: 'year',
        getVisibleDates: function (date, selected) {
          var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
          for (var i = 0; i < yearRange; i++) {
            var dt = new Date(startYear + i, 0, 1);
            years[i] = makeDate(dt, format.year, selected && selected.getFullYear() === dt.getFullYear());
          }
          return {
            objects: years,
            title: [
              years[0].label,
              years[yearRange - 1].label
            ].join(' - ')
          };
        },
        compare: function (date1, date2) {
          return date1.getFullYear() - date2.getFullYear();
        },
        split: 5,
        step: { years: yearRange }
      }
    ];
    this.isDisabled = function (date, mode) {
      var currentMode = this.modes[mode || 0];
      return this.minDate && currentMode.compare(date, this.minDate) < 0 || this.maxDate && currentMode.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
        date: date,
        mode: currentMode.name
      });
    };
  }
]).directive('datepicker', [
  'dateFilter',
  '$parse',
  'datepickerConfig',
  '$log',
  function (dateFilter, $parse, datepickerConfig, $log) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/datepicker/datepicker.html',
      scope: { dateDisabled: '&' },
      require: [
        'datepicker',
        '?^ngModel'
      ],
      controller: 'DatepickerController',
      link: function (scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0], ngModel = ctrls[1];
        if (!ngModel) {
          return;
        }
        var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;
        if (attrs.showWeeks) {
          scope.$parent.$watch($parse(attrs.showWeeks), function (value) {
            showWeeks = !!value;
            updateShowWeekNumbers();
          });
        } else {
          updateShowWeekNumbers();
        }
        if (attrs.min) {
          scope.$parent.$watch($parse(attrs.min), function (value) {
            datepickerCtrl.minDate = value ? new Date(value) : null;
            refill();
          });
        }
        if (attrs.max) {
          scope.$parent.$watch($parse(attrs.max), function (value) {
            datepickerCtrl.maxDate = value ? new Date(value) : null;
            refill();
          });
        }
        function updateShowWeekNumbers() {
          scope.showWeekNumbers = mode === 0 && showWeeks;
        }
        function split(arr, size) {
          var arrays = [];
          while (arr.length > 0) {
            arrays.push(arr.splice(0, size));
          }
          return arrays;
        }
        function refill(updateSelected) {
          var date = null, valid = true;
          if (ngModel.$modelValue) {
            date = new Date(ngModel.$modelValue);
            if (isNaN(date)) {
              valid = false;
              $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
            } else if (updateSelected) {
              selected = date;
            }
          }
          ngModel.$setValidity('date', valid);
          var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
          angular.forEach(data.objects, function (obj) {
            obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
          });
          ngModel.$setValidity('date-disabled', !date || !datepickerCtrl.isDisabled(date));
          scope.rows = split(data.objects, currentMode.split);
          scope.labels = data.labels || [];
          scope.title = data.title;
        }
        function setMode(value) {
          mode = value;
          updateShowWeekNumbers();
          refill();
        }
        ngModel.$render = function () {
          refill(true);
        };
        scope.select = function (date) {
          if (mode === 0) {
            var dt = ngModel.$modelValue ? new Date(ngModel.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
            ngModel.$setViewValue(dt);
            refill(true);
          } else {
            selected = date;
            setMode(mode - 1);
          }
        };
        scope.move = function (direction) {
          var step = datepickerCtrl.modes[mode].step;
          selected.setMonth(selected.getMonth() + direction * (step.months || 0));
          selected.setFullYear(selected.getFullYear() + direction * (step.years || 0));
          refill();
        };
        scope.toggleMode = function () {
          setMode((mode + 1) % datepickerCtrl.modes.length);
        };
        scope.getWeekNumber = function (row) {
          return mode === 0 && scope.showWeekNumbers && row.length === 7 ? getISO8601WeekNumber(row[0].date) : null;
        };
        function getISO8601WeekNumber(date) {
          var checkDate = new Date(date);
          checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
          var time = checkDate.getTime();
          checkDate.setMonth(0);
          checkDate.setDate(1);
          return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        }
      }
    };
  }
]).constant('datepickerPopupConfig', {
  dateFormat: 'yyyy-MM-dd',
  currentText: 'Today',
  toggleWeeksText: 'Weeks',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true
}).directive('datepickerPopup', [
  '$compile',
  '$parse',
  '$document',
  '$position',
  'dateFilter',
  'datepickerPopupConfig',
  'datepickerConfig',
  function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig, datepickerConfig) {
    return {
      restrict: 'EA',
      require: 'ngModel',
      link: function (originalScope, element, attrs, ngModel) {
        var scope = originalScope.$new(), dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? originalScope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? originalScope.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        attrs.$observe('datepickerPopup', function (value) {
          dateFormat = value || datepickerPopupConfig.dateFormat;
          ngModel.$render();
        });
        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? originalScope.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        originalScope.$on('$destroy', function () {
          $popup.remove();
          scope.$destroy();
        });
        attrs.$observe('currentText', function (text) {
          scope.currentText = angular.isDefined(text) ? text : datepickerPopupConfig.currentText;
        });
        attrs.$observe('toggleWeeksText', function (text) {
          scope.toggleWeeksText = angular.isDefined(text) ? text : datepickerPopupConfig.toggleWeeksText;
        });
        attrs.$observe('clearText', function (text) {
          scope.clearText = angular.isDefined(text) ? text : datepickerPopupConfig.clearText;
        });
        attrs.$observe('closeText', function (text) {
          scope.closeText = angular.isDefined(text) ? text : datepickerPopupConfig.closeText;
        });
        var getIsOpen, setIsOpen;
        if (attrs.isOpen) {
          getIsOpen = $parse(attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          originalScope.$watch(getIsOpen, function updateOpen(value) {
            scope.isOpen = !!value;
          });
        }
        scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false;
        function setOpen(value) {
          if (setIsOpen) {
            setIsOpen(originalScope, !!value);
          } else {
            scope.isOpen = !!value;
          }
        }
        var documentClickBind = function (event) {
          if (scope.isOpen && event.target !== element[0]) {
            scope.$apply(function () {
              setOpen(false);
            });
          }
        };
        var elementFocusBind = function () {
          scope.$apply(function () {
            setOpen(true);
          });
        };
        var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
        popupEl.attr({
          'ng-model': 'date',
          'ng-change': 'dateSelection()'
        });
        var datepickerEl = angular.element(popupEl.children()[0]), datepickerOptions = {};
        if (attrs.datepickerOptions) {
          datepickerOptions = originalScope.$eval(attrs.datepickerOptions);
          datepickerEl.attr(angular.extend({}, datepickerOptions));
        }
        function parseDate(viewValue) {
          if (!viewValue) {
            ngModel.$setValidity('date', true);
            return null;
          } else if (angular.isDate(viewValue)) {
            ngModel.$setValidity('date', true);
            return viewValue;
          } else if (angular.isString(viewValue)) {
            var date = new Date(viewValue);
            if (isNaN(date)) {
              ngModel.$setValidity('date', false);
              return undefined;
            } else {
              ngModel.$setValidity('date', true);
              return date;
            }
          } else {
            ngModel.$setValidity('date', false);
            return undefined;
          }
        }
        ngModel.$parsers.unshift(parseDate);
        scope.dateSelection = function (dt) {
          if (angular.isDefined(dt)) {
            scope.date = dt;
          }
          ngModel.$setViewValue(scope.date);
          ngModel.$render();
          if (closeOnDateSelection) {
            setOpen(false);
          }
        };
        element.bind('input change keyup', function () {
          scope.$apply(function () {
            scope.date = ngModel.$modelValue;
          });
        });
        ngModel.$render = function () {
          var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
          element.val(date);
          scope.date = ngModel.$modelValue;
        };
        function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
          if (attribute) {
            originalScope.$watch($parse(attribute), function (value) {
              scope[scopeProperty] = value;
            });
            datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
          }
        }
        addWatchableAttribute(attrs.min, 'min');
        addWatchableAttribute(attrs.max, 'max');
        if (attrs.showWeeks) {
          addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
        } else {
          scope.showWeeks = 'show-weeks' in datepickerOptions ? datepickerOptions['show-weeks'] : datepickerConfig.showWeeks;
          datepickerEl.attr('show-weeks', 'showWeeks');
        }
        if (attrs.dateDisabled) {
          datepickerEl.attr('date-disabled', attrs.dateDisabled);
        }
        function updatePosition() {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');
        }
        var documentBindingInitialized = false, elementFocusInitialized = false;
        scope.$watch('isOpen', function (value) {
          if (value) {
            updatePosition();
            $document.bind('click', documentClickBind);
            if (elementFocusInitialized) {
              element.unbind('focus', elementFocusBind);
            }
            element[0].focus();
            documentBindingInitialized = true;
          } else {
            if (documentBindingInitialized) {
              $document.unbind('click', documentClickBind);
            }
            element.bind('focus', elementFocusBind);
            elementFocusInitialized = true;
          }
          if (setIsOpen) {
            setIsOpen(originalScope, value);
          }
        });
        scope.today = function () {
          scope.dateSelection(new Date());
        };
        scope.clear = function () {
          scope.dateSelection(null);
        };
        var $popup = $compile(popupEl)(scope);
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          element.after($popup);
        }
      }
    };
  }
]).directive('datepickerPopupWrap', function () {
  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link: function (scope, element, attrs) {
      element.bind('click', function (event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});
angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', [
  '$document',
  '$location',
  function ($document, $location) {
    var openElement = null, closeMenu = angular.noop;
    return {
      restrict: 'CA',
      link: function (scope, element, attrs) {
        scope.$watch('$location.path', function () {
          closeMenu();
        });
        element.parent().bind('click', function () {
          closeMenu();
        });
        element.bind('click', function (event) {
          var elementWasOpen = element === openElement;
          event.preventDefault();
          event.stopPropagation();
          if (!!openElement) {
            closeMenu();
          }
          if (!elementWasOpen && !element.hasClass('disabled') && !element.prop('disabled')) {
            element.parent().addClass('open');
            openElement = element;
            closeMenu = function (event) {
              if (event) {
                event.preventDefault();
                event.stopPropagation();
              }
              $document.unbind('click', closeMenu);
              element.parent().removeClass('open');
              closeMenu = angular.noop;
              openElement = null;
            };
            $document.bind('click', closeMenu);
          }
        });
      }
    };
  }
]);
angular.module('ui.bootstrap.modal', ['ui.bootstrap.transition']).factory('$$stackedMap', function () {
  return {
    createNew: function () {
      var stack = [];
      return {
        add: function (key, value) {
          stack.push({
            key: key,
            value: value
          });
        },
        get: function (key) {
          for (var i = 0; i < stack.length; i++) {
            if (key == stack[i].key) {
              return stack[i];
            }
          }
        },
        keys: function () {
          var keys = [];
          for (var i = 0; i < stack.length; i++) {
            keys.push(stack[i].key);
          }
          return keys;
        },
        top: function () {
          return stack[stack.length - 1];
        },
        remove: function (key) {
          var idx = -1;
          for (var i = 0; i < stack.length; i++) {
            if (key == stack[i].key) {
              idx = i;
              break;
            }
          }
          return stack.splice(idx, 1)[0];
        },
        removeTop: function () {
          return stack.splice(stack.length - 1, 1)[0];
        },
        length: function () {
          return stack.length;
        }
      };
    }
  };
}).directive('modalBackdrop', [
  '$timeout',
  function ($timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      link: function (scope) {
        scope.animate = false;
        $timeout(function () {
          scope.animate = true;
        });
      }
    };
  }
]).directive('modalWindow', [
  '$modalStack',
  '$timeout',
  function ($modalStack, $timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@',
        animate: '='
      },
      replace: true,
      transclude: true,
      templateUrl: 'template/modal/window.html',
      link: function (scope, element, attrs) {
        scope.windowClass = attrs.windowClass || '';
        $timeout(function () {
          scope.animate = true;
          element[0].focus();
        });
        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && evt.target === evt.currentTarget) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
      }
    };
  }
]).factory('$modalStack', [
  '$transition',
  '$timeout',
  '$document',
  '$compile',
  '$rootScope',
  '$$stackedMap',
  function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    var OPENED_MODAL_CLASS = 'modal-open';
    var backdropDomEl, backdropScope;
    var openedWindows = $$stackedMap.createNew();
    var $modalStack = {};
    function backdropIndex() {
      var topBackdropIndex = -1;
      var opened = openedWindows.keys();
      for (var i = 0; i < opened.length; i++) {
        if (openedWindows.get(opened[i]).value.backdrop) {
          topBackdropIndex = i;
        }
      }
      return topBackdropIndex;
    }
    $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
      if (backdropScope) {
        backdropScope.index = newBackdropIndex;
      }
    });
    function removeModalWindow(modalInstance) {
      var body = $document.find('body').eq(0);
      var modalWindow = openedWindows.get(modalInstance).value;
      openedWindows.remove(modalInstance);
      removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, checkRemoveBackdrop);
      body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
    }
    function checkRemoveBackdrop() {
      if (backdropDomEl && backdropIndex() == -1) {
        var backdropScopeRef = backdropScope;
        removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
          backdropScopeRef.$destroy();
          backdropScopeRef = null;
        });
        backdropDomEl = undefined;
        backdropScope = undefined;
      }
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
      scope.animate = false;
      var transitionEndEventName = $transition.transitionEndEventName;
      if (transitionEndEventName) {
        var timeout = $timeout(afterAnimating, emulateTime);
        domEl.bind(transitionEndEventName, function () {
          $timeout.cancel(timeout);
          afterAnimating();
          scope.$apply();
        });
      } else {
        $timeout(afterAnimating, 0);
      }
      function afterAnimating() {
        if (afterAnimating.done) {
          return;
        }
        afterAnimating.done = true;
        domEl.remove();
        if (done) {
          done();
        }
      }
    }
    $document.bind('keydown', function (evt) {
      var modal;
      if (evt.which === 27) {
        modal = openedWindows.top();
        if (modal && modal.value.keyboard) {
          $rootScope.$apply(function () {
            $modalStack.dismiss(modal.key);
          });
        }
      }
    });
    $modalStack.open = function (modalInstance, modal) {
      openedWindows.add(modalInstance, {
        deferred: modal.deferred,
        modalScope: modal.scope,
        backdrop: modal.backdrop,
        keyboard: modal.keyboard
      });
      var body = $document.find('body').eq(0), currBackdropIndex = backdropIndex();
      if (currBackdropIndex >= 0 && !backdropDomEl) {
        backdropScope = $rootScope.$new(true);
        backdropScope.index = currBackdropIndex;
        backdropDomEl = $compile('<div modal-backdrop></div>')(backdropScope);
        body.append(backdropDomEl);
      }
      var angularDomEl = angular.element('<div modal-window></div>');
      angularDomEl.attr('window-class', modal.windowClass);
      angularDomEl.attr('index', openedWindows.length() - 1);
      angularDomEl.attr('animate', 'animate');
      angularDomEl.html(modal.content);
      var modalDomEl = $compile(angularDomEl)(modal.scope);
      openedWindows.top().value.modalDomEl = modalDomEl;
      body.append(modalDomEl);
      body.addClass(OPENED_MODAL_CLASS);
    };
    $modalStack.close = function (modalInstance, result) {
      var modalWindow = openedWindows.get(modalInstance).value;
      if (modalWindow) {
        modalWindow.deferred.resolve(result);
        removeModalWindow(modalInstance);
      }
    };
    $modalStack.dismiss = function (modalInstance, reason) {
      var modalWindow = openedWindows.get(modalInstance).value;
      if (modalWindow) {
        modalWindow.deferred.reject(reason);
        removeModalWindow(modalInstance);
      }
    };
    $modalStack.dismissAll = function (reason) {
      var topModal = this.getTop();
      while (topModal) {
        this.dismiss(topModal.key, reason);
        topModal = this.getTop();
      }
    };
    $modalStack.getTop = function () {
      return openedWindows.top();
    };
    return $modalStack;
  }
]).provider('$modal', function () {
  var $modalProvider = {
      options: {
        backdrop: true,
        keyboard: true
      },
      $get: [
        '$injector',
        '$rootScope',
        '$q',
        '$http',
        '$templateCache',
        '$controller',
        '$modalStack',
        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $http.get(options.templateUrl, { cache: $templateCache }).then(function (result) {
              return result.data;
            });
          }
          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }
          $modal.open = function (modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalInstance = {
                result: modalResultDeferred.promise,
                opened: modalOpenedDeferred.promise,
                close: function (result) {
                  $modalStack.close(modalInstance, result);
                },
                dismiss: function (reason) {
                  $modalStack.dismiss(modalInstance, reason);
                }
              };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });
                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass
              });
            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });
            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function () {
              modalOpenedDeferred.reject(false);
            });
            return modalInstance;
          };
          return $modal;
        }
      ]
    };
  return $modalProvider;
});
angular.module('ui.bootstrap.pagination', []).controller('PaginationController', [
  '$scope',
  '$attrs',
  '$parse',
  '$interpolate',
  function ($scope, $attrs, $parse, $interpolate) {
    var self = this, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function (defaultItemsPerPage) {
      if ($attrs.itemsPerPage) {
        $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {
          self.itemsPerPage = parseInt(value, 10);
          $scope.totalPages = self.calculateTotalPages();
        });
      } else {
        this.itemsPerPage = defaultItemsPerPage;
      }
    };
    this.noPrevious = function () {
      return this.page === 1;
    };
    this.noNext = function () {
      return this.page === $scope.totalPages;
    };
    this.isActive = function (page) {
      return this.page === page;
    };
    this.calculateTotalPages = function () {
      var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
      return Math.max(totalPages || 0, 1);
    };
    this.getAttributeValue = function (attribute, defaultValue, interpolate) {
      return angular.isDefined(attribute) ? interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute) : defaultValue;
    };
    this.render = function () {
      this.page = parseInt($scope.page, 10) || 1;
      if (this.page > 0 && this.page <= $scope.totalPages) {
        $scope.pages = this.getPages(this.page, $scope.totalPages);
      }
    };
    $scope.selectPage = function (page) {
      if (!self.isActive(page) && page > 0 && page <= $scope.totalPages) {
        $scope.page = page;
        $scope.onSelectPage({ page: page });
      }
    };
    $scope.$watch('page', function () {
      self.render();
    });
    $scope.$watch('totalItems', function () {
      $scope.totalPages = self.calculateTotalPages();
    });
    $scope.$watch('totalPages', function (value) {
      setNumPages($scope.$parent, value);
      if (self.page > value) {
        $scope.selectPage(value);
      } else {
        self.render();
      }
    });
  }
]).constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
}).directive('pagination', [
  '$parse',
  'paginationConfig',
  function ($parse, config) {
    return {
      restrict: 'EA',
      scope: {
        page: '=',
        totalItems: '=',
        onSelectPage: ' &'
      },
      controller: 'PaginationController',
      templateUrl: 'template/pagination/pagination.html',
      replace: true,
      link: function (scope, element, attrs, paginationCtrl) {
        var maxSize, boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks), directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks), firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, true), previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true), lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, true), rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);
        paginationCtrl.init(config.itemsPerPage);
        if (attrs.maxSize) {
          scope.$parent.$watch($parse(attrs.maxSize), function (value) {
            maxSize = parseInt(value, 10);
            paginationCtrl.render();
          });
        }
        function makePage(number, text, isActive, isDisabled) {
          return {
            number: number,
            text: text,
            active: isActive,
            disabled: isDisabled
          };
        }
        paginationCtrl.getPages = function (currentPage, totalPages) {
          var pages = [];
          var startPage = 1, endPage = totalPages;
          var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
          if (isMaxSized) {
            if (rotate) {
              startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
              endPage = startPage + maxSize - 1;
              if (endPage > totalPages) {
                endPage = totalPages;
                startPage = endPage - maxSize + 1;
              }
            } else {
              startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
              endPage = Math.min(startPage + maxSize - 1, totalPages);
            }
          }
          for (var number = startPage; number <= endPage; number++) {
            var page = makePage(number, number, paginationCtrl.isActive(number), false);
            pages.push(page);
          }
          if (isMaxSized && !rotate) {
            if (startPage > 1) {
              var previousPageSet = makePage(startPage - 1, '...', false, false);
              pages.unshift(previousPageSet);
            }
            if (endPage < totalPages) {
              var nextPageSet = makePage(endPage + 1, '...', false, false);
              pages.push(nextPageSet);
            }
          }
          if (directionLinks) {
            var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
            pages.unshift(previousPage);
            var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
            pages.push(nextPage);
          }
          if (boundaryLinks) {
            var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
            pages.unshift(firstPage);
            var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
            pages.push(lastPage);
          }
          return pages;
        };
      }
    };
  }
]).constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: '\xab Previous',
  nextText: 'Next \xbb',
  align: true
}).directive('pager', [
  'pagerConfig',
  function (config) {
    return {
      restrict: 'EA',
      scope: {
        page: '=',
        totalItems: '=',
        onSelectPage: ' &'
      },
      controller: 'PaginationController',
      templateUrl: 'template/pagination/pager.html',
      replace: true,
      link: function (scope, element, attrs, paginationCtrl) {
        var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true), align = paginationCtrl.getAttributeValue(attrs.align, config.align);
        paginationCtrl.init(config.itemsPerPage);
        function makePage(number, text, isDisabled, isPrevious, isNext) {
          return {
            number: number,
            text: text,
            disabled: isDisabled,
            previous: align && isPrevious,
            next: align && isNext
          };
        }
        paginationCtrl.getPages = function (currentPage) {
          return [
            makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
            makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
          ];
        };
      }
    };
  }
]);
angular.module('ui.bootstrap.tooltip', [
  'ui.bootstrap.position',
  'ui.bootstrap.bindHtml'
]).provider('$tooltip', function () {
  var defaultOptions = {
      placement: 'top',
      animation: true,
      popupDelay: 0
    };
  var triggerMap = {
      'mouseenter': 'mouseleave',
      'click': 'click',
      'focus': 'blur'
    };
  var globalOptions = {};
  this.options = function (value) {
    angular.extend(globalOptions, value);
  };
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  this.$get = [
    '$window',
    '$compile',
    '$timeout',
    '$parse',
    '$document',
    '$position',
    '$interpolate',
    function ($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
      return function $tooltip(type, prefix, defaultTriggerShow) {
        var options = angular.extend({}, defaultOptions, globalOptions);
        function getTriggers(trigger) {
          var show = trigger || options.trigger || defaultTriggerShow;
          var hide = triggerMap[show] || show;
          return {
            show: show,
            hide: hide
          };
        }
        var directiveName = snake_case(type);
        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();
        var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'tt_title' + endSym + '" ' + 'content="' + startSym + 'tt_content' + endSym + '" ' + 'placement="' + startSym + 'tt_placement' + endSym + '" ' + 'animation="tt_animation" ' + 'is-open="tt_isOpen"' + '>' + '</div>';
        return {
          restrict: 'EA',
          scope: true,
          compile: function (tElem, tAttrs) {
            var tooltipLinker = $compile(template);
            return function link(scope, element, attrs) {
              var tooltip;
              var transitionTimeout;
              var popupTimeout;
              var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
              var triggers = getTriggers(undefined);
              var hasRegisteredTriggers = false;
              var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
              var positionTooltip = function () {
                var position, ttWidth, ttHeight, ttPosition;
                position = appendToBody ? $position.offset(element) : $position.position(element);
                ttWidth = tooltip.prop('offsetWidth');
                ttHeight = tooltip.prop('offsetHeight');
                switch (scope.tt_placement) {
                case 'right':
                  ttPosition = {
                    top: position.top + position.height / 2 - ttHeight / 2,
                    left: position.left + position.width
                  };
                  break;
                case 'bottom':
                  ttPosition = {
                    top: position.top + position.height,
                    left: position.left + position.width / 2 - ttWidth / 2
                  };
                  break;
                case 'left':
                  ttPosition = {
                    top: position.top + position.height / 2 - ttHeight / 2,
                    left: position.left - ttWidth
                  };
                  break;
                default:
                  ttPosition = {
                    top: position.top - ttHeight,
                    left: position.left + position.width / 2 - ttWidth / 2
                  };
                  break;
                }
                ttPosition.top += 'px';
                ttPosition.left += 'px';
                tooltip.css(ttPosition);
              };
              scope.tt_isOpen = false;
              function toggleTooltipBind() {
                if (!scope.tt_isOpen) {
                  showTooltipBind();
                } else {
                  hideTooltipBind();
                }
              }
              function showTooltipBind() {
                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                  return;
                }
                if (scope.tt_popupDelay) {
                  popupTimeout = $timeout(show, scope.tt_popupDelay, false);
                  popupTimeout.then(function (reposition) {
                    reposition();
                  });
                } else {
                  show()();
                }
              }
              function hideTooltipBind() {
                scope.$apply(function () {
                  hide();
                });
              }
              function show() {
                if (!scope.tt_content) {
                  return angular.noop;
                }
                createTooltip();
                if (transitionTimeout) {
                  $timeout.cancel(transitionTimeout);
                }
                tooltip.css({
                  top: 0,
                  left: 0,
                  display: 'block'
                });
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
                positionTooltip();
                scope.tt_isOpen = true;
                scope.$digest();
                return positionTooltip;
              }
              function hide() {
                scope.tt_isOpen = false;
                $timeout.cancel(popupTimeout);
                if (scope.tt_animation) {
                  transitionTimeout = $timeout(removeTooltip, 500);
                } else {
                  removeTooltip();
                }
              }
              function createTooltip() {
                if (tooltip) {
                  removeTooltip();
                }
                tooltip = tooltipLinker(scope, function () {
                });
                scope.$digest();
              }
              function removeTooltip() {
                if (tooltip) {
                  tooltip.remove();
                  tooltip = null;
                }
              }
              attrs.$observe(type, function (val) {
                scope.tt_content = val;
                if (!val && scope.tt_isOpen) {
                  hide();
                }
              });
              attrs.$observe(prefix + 'Title', function (val) {
                scope.tt_title = val;
              });
              attrs.$observe(prefix + 'Placement', function (val) {
                scope.tt_placement = angular.isDefined(val) ? val : options.placement;
              });
              attrs.$observe(prefix + 'PopupDelay', function (val) {
                var delay = parseInt(val, 10);
                scope.tt_popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              });
              var unregisterTriggers = function () {
                if (hasRegisteredTriggers) {
                  element.unbind(triggers.show, showTooltipBind);
                  element.unbind(triggers.hide, hideTooltipBind);
                }
              };
              attrs.$observe(prefix + 'Trigger', function (val) {
                unregisterTriggers();
                triggers = getTriggers(val);
                if (triggers.show === triggers.hide) {
                  element.bind(triggers.show, toggleTooltipBind);
                } else {
                  element.bind(triggers.show, showTooltipBind);
                  element.bind(triggers.hide, hideTooltipBind);
                }
                hasRegisteredTriggers = true;
              });
              var animation = scope.$eval(attrs[prefix + 'Animation']);
              scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;
              attrs.$observe(prefix + 'AppendToBody', function (val) {
                appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
              });
              if (appendToBody) {
                scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                  if (scope.tt_isOpen) {
                    hide();
                  }
                });
              }
              scope.$on('$destroy', function onDestroyTooltip() {
                $timeout.cancel(transitionTimeout);
                $timeout.cancel(popupTimeout);
                unregisterTriggers();
                removeTooltip();
              });
            };
          }
        };
      };
    }
  ];
}).directive('tooltipPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: {
      content: '@',
      placement: '@',
      animation: '&',
      isOpen: '&'
    },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
}).directive('tooltip', [
  '$tooltip',
  function ($tooltip) {
    return $tooltip('tooltip', 'tooltip', 'mouseenter');
  }
]).directive('tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: {
      content: '@',
      placement: '@',
      animation: '&',
      isOpen: '&'
    },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
}).directive('tooltipHtmlUnsafe', [
  '$tooltip',
  function ($tooltip) {
    return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
  }
]);
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: {
      title: '@',
      content: '@',
      placement: '@',
      animation: '&',
      isOpen: '&'
    },
    templateUrl: 'template/popover/popover.html'
  };
}).directive('popover', [
  '$tooltip',
  function ($tooltip) {
    return $tooltip('popover', 'popover', 'click');
  }
]);
angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition']).constant('progressConfig', {
  animate: true,
  max: 100
}).controller('ProgressController', [
  '$scope',
  '$attrs',
  'progressConfig',
  '$transition',
  function ($scope, $attrs, progressConfig, $transition) {
    var self = this, bars = [], max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.addBar = function (bar, element) {
      var oldValue = 0, index = bar.$parent.$index;
      if (angular.isDefined(index) && bars[index]) {
        oldValue = bars[index].value;
      }
      bars.push(bar);
      this.update(element, bar.value, oldValue);
      bar.$watch('value', function (value, oldValue) {
        if (value !== oldValue) {
          self.update(element, value, oldValue);
        }
      });
      bar.$on('$destroy', function () {
        self.removeBar(bar);
      });
    };
    this.update = function (element, newValue, oldValue) {
      var percent = this.getPercentage(newValue);
      if (animate) {
        element.css('width', this.getPercentage(oldValue) + '%');
        $transition(element, { width: percent + '%' });
      } else {
        element.css({
          'transition': 'none',
          'width': percent + '%'
        });
      }
    };
    this.removeBar = function (bar) {
      bars.splice(bars.indexOf(bar), 1);
    };
    this.getPercentage = function (value) {
      return Math.round(100 * value / max);
    };
  }
]).directive('progress', function () {
  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    require: 'progress',
    scope: {},
    template: '<div class="progress" ng-transclude></div>'
  };
}).directive('bar', function () {
  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    require: '^progress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/bar.html',
    link: function (scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element);
    }
  };
}).directive('progressbar', function () {
  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/progressbar.html',
    link: function (scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]));
    }
  };
});
angular.module('ui.bootstrap.rating', []).constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
}).controller('RatingController', [
  '$scope',
  '$attrs',
  '$parse',
  'ratingConfig',
  function ($scope, $attrs, $parse, ratingConfig) {
    this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.createRateObjects = function (states) {
      var defaultOptions = {
          stateOn: this.stateOn,
          stateOff: this.stateOff
        };
      for (var i = 0, n = states.length; i < n; i++) {
        states[i] = angular.extend({ index: i }, defaultOptions, states[i]);
      }
      return states;
    };
    $scope.range = angular.isDefined($attrs.ratingStates) ? this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))) : this.createRateObjects(new Array(this.maxRange));
    $scope.rate = function (value) {
      if ($scope.value !== value && !$scope.readonly) {
        $scope.value = value;
      }
    };
    $scope.enter = function (value) {
      if (!$scope.readonly) {
        $scope.val = value;
      }
      $scope.onHover({ value: value });
    };
    $scope.reset = function () {
      $scope.val = angular.copy($scope.value);
      $scope.onLeave();
    };
    $scope.$watch('value', function (value) {
      $scope.val = value;
    });
    $scope.readonly = false;
    if ($attrs.readonly) {
      $scope.$parent.$watch($parse($attrs.readonly), function (value) {
        $scope.readonly = !!value;
      });
    }
  }
]).directive('rating', function () {
  return {
    restrict: 'EA',
    scope: {
      value: '=',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true
  };
});
angular.module('ui.bootstrap.tabs', []).controller('TabsetController', [
  '$scope',
  function TabsetCtrl($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function (tab) {
      angular.forEach(tabs, function (tab) {
        tab.active = false;
      });
      tab.active = true;
    };
    ctrl.addTab = function addTab(tab) {
      tabs.push(tab);
      if (tabs.length === 1 || tab.active) {
        ctrl.select(tab);
      }
    };
    ctrl.removeTab = function removeTab(tab) {
      var index = tabs.indexOf(tab);
      if (tab.active && tabs.length > 1) {
        var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
        ctrl.select(tabs[newActiveIndex]);
      }
      tabs.splice(index, 1);
    };
  }
]).directive('tabset', function () {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {},
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function (scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
      scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
    }
  };
}).directive('tab', [
  '$parse',
  function ($parse) {
    return {
      require: '^tabset',
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/tabs/tab.html',
      transclude: true,
      scope: {
        heading: '@',
        onSelect: '&select',
        onDeselect: '&deselect'
      },
      controller: function () {
      },
      compile: function (elm, attrs, transclude) {
        return function postLink(scope, elm, attrs, tabsetCtrl) {
          var getActive, setActive;
          if (attrs.active) {
            getActive = $parse(attrs.active);
            setActive = getActive.assign;
            scope.$parent.$watch(getActive, function updateActive(value, oldVal) {
              if (value !== oldVal) {
                scope.active = !!value;
              }
            });
            scope.active = getActive(scope.$parent);
          } else {
            setActive = getActive = angular.noop;
          }
          scope.$watch('active', function (active) {
            setActive(scope.$parent, active);
            if (active) {
              tabsetCtrl.select(scope);
              scope.onSelect();
            } else {
              scope.onDeselect();
            }
          });
          scope.disabled = false;
          if (attrs.disabled) {
            scope.$parent.$watch($parse(attrs.disabled), function (value) {
              scope.disabled = !!value;
            });
          }
          scope.select = function () {
            if (!scope.disabled) {
              scope.active = true;
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function () {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        };
      }
    };
  }
]).directive('tabHeadingTransclude', [function () {
    return {
      restrict: 'A',
      require: '^tab',
      link: function (scope, elm, attrs, tabCtrl) {
        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  }]).directive('tabContentTransclude', function () {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function (scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);
      tab.$transcludeFn(tab.$parent, function (contents) {
        angular.forEach(contents, function (node) {
          if (isTabHeading(node)) {
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading');
  }
});
;
angular.module('ui.bootstrap.timepicker', []).constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true
}).directive('timepicker', [
  '$parse',
  '$log',
  'timepickerConfig',
  '$locale',
  function ($parse, $log, timepickerConfig, $locale) {
    return {
      restrict: 'EA',
      require: '?^ngModel',
      replace: true,
      scope: {},
      templateUrl: 'template/timepicker/timepicker.html',
      link: function (scope, element, attrs, ngModel) {
        if (!ngModel) {
          return;
        }
        var selected = new Date(), meridians = angular.isDefined(attrs.meridians) ? scope.$parent.$eval(attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
        var hourStep = timepickerConfig.hourStep;
        if (attrs.hourStep) {
          scope.$parent.$watch($parse(attrs.hourStep), function (value) {
            hourStep = parseInt(value, 10);
          });
        }
        var minuteStep = timepickerConfig.minuteStep;
        if (attrs.minuteStep) {
          scope.$parent.$watch($parse(attrs.minuteStep), function (value) {
            minuteStep = parseInt(value, 10);
          });
        }
        scope.showMeridian = timepickerConfig.showMeridian;
        if (attrs.showMeridian) {
          scope.$parent.$watch($parse(attrs.showMeridian), function (value) {
            scope.showMeridian = !!value;
            if (ngModel.$error.time) {
              var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
              if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                selected.setHours(hours);
                refresh();
              }
            } else {
              updateTemplate();
            }
          });
        }
        function getHoursFromTemplate() {
          var hours = parseInt(scope.hours, 10);
          var valid = scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
          if (!valid) {
            return undefined;
          }
          if (scope.showMeridian) {
            if (hours === 12) {
              hours = 0;
            }
            if (scope.meridian === meridians[1]) {
              hours = hours + 12;
            }
          }
          return hours;
        }
        function getMinutesFromTemplate() {
          var minutes = parseInt(scope.minutes, 10);
          return minutes >= 0 && minutes < 60 ? minutes : undefined;
        }
        function pad(value) {
          return angular.isDefined(value) && value.toString().length < 2 ? '0' + value : value;
        }
        var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);
        var mousewheel = angular.isDefined(attrs.mousewheel) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
          var isScrollingUp = function (e) {
            if (e.originalEvent) {
              e = e.originalEvent;
            }
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
          };
          hoursInputEl.bind('mousewheel wheel', function (e) {
            scope.$apply(isScrollingUp(e) ? scope.incrementHours() : scope.decrementHours());
            e.preventDefault();
          });
          minutesInputEl.bind('mousewheel wheel', function (e) {
            scope.$apply(isScrollingUp(e) ? scope.incrementMinutes() : scope.decrementMinutes());
            e.preventDefault();
          });
        }
        scope.readonlyInput = angular.isDefined(attrs.readonlyInput) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
        if (!scope.readonlyInput) {
          var invalidate = function (invalidHours, invalidMinutes) {
            ngModel.$setViewValue(null);
            ngModel.$setValidity('time', false);
            if (angular.isDefined(invalidHours)) {
              scope.invalidHours = invalidHours;
            }
            if (angular.isDefined(invalidMinutes)) {
              scope.invalidMinutes = invalidMinutes;
            }
          };
          scope.updateHours = function () {
            var hours = getHoursFromTemplate();
            if (angular.isDefined(hours)) {
              selected.setHours(hours);
              refresh('h');
            } else {
              invalidate(true);
            }
          };
          hoursInputEl.bind('blur', function (e) {
            if (!scope.validHours && scope.hours < 10) {
              scope.$apply(function () {
                scope.hours = pad(scope.hours);
              });
            }
          });
          scope.updateMinutes = function () {
            var minutes = getMinutesFromTemplate();
            if (angular.isDefined(minutes)) {
              selected.setMinutes(minutes);
              refresh('m');
            } else {
              invalidate(undefined, true);
            }
          };
          minutesInputEl.bind('blur', function (e) {
            if (!scope.invalidMinutes && scope.minutes < 10) {
              scope.$apply(function () {
                scope.minutes = pad(scope.minutes);
              });
            }
          });
        } else {
          scope.updateHours = angular.noop;
          scope.updateMinutes = angular.noop;
        }
        ngModel.$render = function () {
          var date = ngModel.$modelValue ? new Date(ngModel.$modelValue) : null;
          if (isNaN(date)) {
            ngModel.$setValidity('time', false);
            $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          } else {
            if (date) {
              selected = date;
            }
            makeValid();
            updateTemplate();
          }
        };
        function refresh(keyboardChange) {
          makeValid();
          ngModel.$setViewValue(new Date(selected));
          updateTemplate(keyboardChange);
        }
        function makeValid() {
          ngModel.$setValidity('time', true);
          scope.invalidHours = false;
          scope.invalidMinutes = false;
        }
        function updateTemplate(keyboardChange) {
          var hours = selected.getHours(), minutes = selected.getMinutes();
          if (scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12;
          }
          scope.hours = keyboardChange === 'h' ? hours : pad(hours);
          scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
          scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
        function addMinutes(minutes) {
          var dt = new Date(selected.getTime() + minutes * 60000);
          selected.setHours(dt.getHours(), dt.getMinutes());
          refresh();
        }
        scope.incrementHours = function () {
          addMinutes(hourStep * 60);
        };
        scope.decrementHours = function () {
          addMinutes(-hourStep * 60);
        };
        scope.incrementMinutes = function () {
          addMinutes(minuteStep);
        };
        scope.decrementMinutes = function () {
          addMinutes(-minuteStep);
        };
        scope.toggleMeridian = function () {
          addMinutes(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
        };
      }
    };
  }
]);
angular.module('ui.bootstrap.typeahead', [
  'ui.bootstrap.position',
  'ui.bootstrap.bindHtml'
]).factory('typeaheadParser', [
  '$parse',
  function ($parse) {
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
      parse: function (input) {
        var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
        if (!match) {
          throw new Error('Expected typeahead specification in form of \'_modelValue_ (as _label_)? for _item_ in _collection_\'' + ' but got \'' + input + '\'.');
        }
        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }
]).directive('typeahead', [
  '$compile',
  '$parse',
  '$q',
  '$timeout',
  '$document',
  '$position',
  'typeaheadParser',
  function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [
        9,
        13,
        27,
        38,
        40
      ];
    return {
      require: 'ngModel',
      link: function (originalScope, element, attrs, modelCtrl) {
        var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);
        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
        var appendToBody = attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : false;
        var $setModelValue = $parse(attrs.ngModel).assign;
        var parserResult = typeaheadParser.parse(attrs.typeahead);
        var hasFocus;
        var popUpEl = angular.element('<div typeahead-popup></div>');
        popUpEl.attr({
          matches: 'matches',
          active: 'activeIdx',
          select: 'select(activeIdx)',
          query: 'query',
          position: 'position'
        });
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }
        var scope = originalScope.$new();
        originalScope.$on('$destroy', function () {
          scope.$destroy();
        });
        var resetMatches = function () {
          scope.matches = [];
          scope.activeIdx = -1;
        };
        var getMatchesAsync = function (inputValue) {
          var locals = { $viewValue: inputValue };
          isLoadingSetter(originalScope, true);
          $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
            if (inputValue === modelCtrl.$viewValue && hasFocus) {
              if (matches.length > 0) {
                scope.activeIdx = 0;
                scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) {
                  locals[parserResult.itemName] = matches[i];
                  scope.matches.push({
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                  });
                }
                scope.query = inputValue;
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top = scope.position.top + element.prop('offsetHeight');
              } else {
                resetMatches();
              }
              isLoadingSetter(originalScope, false);
            }
          }, function () {
            resetMatches();
            isLoadingSetter(originalScope, false);
          });
        };
        resetMatches();
        scope.query = undefined;
        var timeoutPromise;
        modelCtrl.$parsers.unshift(function (inputValue) {
          hasFocus = true;
          if (inputValue && inputValue.length >= minSearch) {
            if (waitTime > 0) {
              if (timeoutPromise) {
                $timeout.cancel(timeoutPromise);
              }
              timeoutPromise = $timeout(function () {
                getMatchesAsync(inputValue);
              }, waitTime);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          } else {
            if (!inputValue) {
              modelCtrl.$setValidity('editable', true);
              return inputValue;
            } else {
              modelCtrl.$setValidity('editable', false);
              return undefined;
            }
          }
        });
        modelCtrl.$formatters.push(function (modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};
          if (inputFormatter) {
            locals['$model'] = modelValue;
            return inputFormatter(originalScope, locals);
          } else {
            locals[parserResult.itemName] = modelValue;
            candidateViewValue = parserResult.viewMapper(originalScope, locals);
            locals[parserResult.itemName] = undefined;
            emptyViewValue = parserResult.viewMapper(originalScope, locals);
            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
          }
        });
        scope.select = function (activeIdx) {
          var locals = {};
          var model, item;
          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
          model = parserResult.modelMapper(originalScope, locals);
          $setModelValue(originalScope, model);
          modelCtrl.$setValidity('editable', true);
          onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals)
          });
          resetMatches();
          element[0].focus();
        };
        element.bind('keydown', function (evt) {
          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
            return;
          }
          evt.preventDefault();
          if (evt.which === 40) {
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
          } else if (evt.which === 38) {
            scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
          } else if (evt.which === 13 || evt.which === 9) {
            scope.$apply(function () {
              scope.select(scope.activeIdx);
            });
          } else if (evt.which === 27) {
            evt.stopPropagation();
            resetMatches();
            scope.$digest();
          }
        });
        element.bind('blur', function (evt) {
          hasFocus = false;
        });
        var dismissClickHandler = function (evt) {
          if (element[0] !== evt.target) {
            resetMatches();
            scope.$digest();
          }
        };
        $document.bind('click', dismissClickHandler);
        originalScope.$on('$destroy', function () {
          $document.unbind('click', dismissClickHandler);
        });
        var $popup = $compile(popUpEl)(scope);
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          element.after($popup);
        }
      }
    };
  }
]).directive('typeaheadPopup', function () {
  return {
    restrict: 'EA',
    scope: {
      matches: '=',
      query: '=',
      active: '=',
      position: '=',
      select: '&'
    },
    replace: true,
    templateUrl: 'template/typeahead/typeahead-popup.html',
    link: function (scope, element, attrs) {
      scope.templateUrl = attrs.templateUrl;
      scope.isOpen = function () {
        return scope.matches.length > 0;
      };
      scope.isActive = function (matchIdx) {
        return scope.active == matchIdx;
      };
      scope.selectActive = function (matchIdx) {
        scope.active = matchIdx;
      };
      scope.selectMatch = function (activeIdx) {
        scope.select({ activeIdx: activeIdx });
      };
    }
  };
}).directive('typeaheadMatch', [
  '$http',
  '$templateCache',
  '$compile',
  '$parse',
  function ($http, $templateCache, $compile, $parse) {
    return {
      restrict: 'EA',
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $http.get(tplUrl, { cache: $templateCache }).success(function (tplContent) {
          element.replaceWith($compile(tplContent.trim())(scope));
        });
      }
    };
  }
]).filter('typeaheadHighlight', function () {
  function escapeRegexp(queryToEscape) {
    return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
  }
  return function (matchItem, query) {
    return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
  };
});
angular.module('template/accordion/accordion-group.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/accordion/accordion-group.html', '<div class="panel panel-default">\n' + '  <div class="panel-heading">\n' + '    <h4 class="panel-title">\n' + '      <a class="accordion-toggle" ng-click="isOpen = !isOpen" accordion-transclude="heading">{{heading}}</a>\n' + '    </h4>\n' + '  </div>\n' + '  <div class="panel-collapse" collapse="!isOpen">\n' + '\t  <div class="panel-body" ng-transclude></div>\n' + '  </div>\n' + '</div>');
  }
]);
angular.module('template/accordion/accordion.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/accordion/accordion.html', '<div class="panel-group" ng-transclude></div>');
  }
]);
angular.module('template/alert/alert.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/alert/alert.html', '<div class=\'alert\' ng-class=\'"alert-" + (type || "warning")\'>\n' + '    <button ng-show=\'closeable\' type=\'button\' class=\'close\' ng-click=\'close()\'>&times;</button>\n' + '    <div ng-transclude></div>\n' + '</div>\n' + '');
  }
]);
angular.module('template/carousel/carousel.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/carousel/carousel.html', '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel">\n' + '    <ol class="carousel-indicators" ng-show="slides().length > 1">\n' + '        <li ng-repeat="slide in slides()" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n' + '    </ol>\n' + '    <div class="carousel-inner" ng-transclude></div>\n' + '    <a class="left carousel-control" ng-click="prev()" ng-show="slides().length > 1"><span class="icon-prev"></span></a>\n' + '    <a class="right carousel-control" ng-click="next()" ng-show="slides().length > 1"><span class="icon-next"></span></a>\n' + '</div>\n' + '');
  }
]);
angular.module('template/carousel/slide.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/carousel/slide.html', '<div ng-class="{\n' + '    \'active\': leaving || (active && !entering),\n' + '    \'prev\': (next || active) && direction==\'prev\',\n' + '    \'next\': (next || active) && direction==\'next\',\n' + '    \'right\': direction==\'prev\',\n' + '    \'left\': direction==\'next\'\n' + '  }" class="item text-center" ng-transclude></div>\n' + '');
  }
]);
angular.module('template/datepicker/datepicker.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/datepicker/datepicker.html', '<table>\n' + '  <thead>\n' + '    <tr>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{rows[0].length - 2 + showWeekNumbers}}"><button type="button" class="btn btn-default btn-sm btn-block" ng-click="toggleMode()"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + '    </tr>\n' + '    <tr ng-show="labels.length > 0" class="h6">\n' + '      <th ng-show="showWeekNumbers" class="text-center">#</th>\n' + '      <th ng-repeat="label in labels" class="text-center">{{label}}</th>\n' + '    </tr>\n' + '  </thead>\n' + '  <tbody>\n' + '    <tr ng-repeat="row in rows">\n' + '      <td ng-show="showWeekNumbers" class="text-center"><em>{{ getWeekNumber(row) }}</em></td>\n' + '      <td ng-repeat="dt in row" class="text-center">\n' + '        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected}" ng-click="select(dt.date)" ng-disabled="dt.disabled"><span ng-class="{\'text-muted\': dt.secondary}">{{dt.label}}</span></button>\n' + '      </td>\n' + '    </tr>\n' + '  </tbody>\n' + '</table>\n' + '');
  }
]);
angular.module('template/datepicker/popup.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/datepicker/popup.html', '<ul class="dropdown-menu" ng-style="{display: (isOpen && \'block\') || \'none\', top: position.top+\'px\', left: position.left+\'px\'}">\n' + '\t<li ng-transclude></li>\n' + '\t<li ng-show="showButtonBar" style="padding:10px 9px 2px">\n' + '\t\t<span class="btn-group">\n' + '\t\t\t<button type="button" class="btn btn-sm btn-info" ng-click="today()">{{currentText}}</button>\n' + '\t\t\t<button type="button" class="btn btn-sm btn-default" ng-click="showWeeks = ! showWeeks" ng-class="{active: showWeeks}">{{toggleWeeksText}}</button>\n' + '\t\t\t<button type="button" class="btn btn-sm btn-danger" ng-click="clear()">{{clearText}}</button>\n' + '\t\t</span>\n' + '\t\t<button type="button" class="btn btn-sm btn-success pull-right" ng-click="isOpen = false">{{closeText}}</button>\n' + '\t</li>\n' + '</ul>\n' + '');
  }
]);
angular.module('template/modal/backdrop.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/modal/backdrop.html', '<div class="modal-backdrop fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1040 + index*10}"></div>');
  }
]);
angular.module('template/modal/window.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/modal/window.html', '<div tabindex="-1" class="modal fade {{ windowClass }}" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n' + '    <div class="modal-dialog"><div class="modal-content" ng-transclude></div></div>\n' + '</div>');
  }
]);
angular.module('template/pagination/pager.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/pagination/pager.html', '<ul class="pager">\n' + '  <li ng-repeat="page in pages" ng-class="{disabled: page.disabled, previous: page.previous, next: page.next}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' + '</ul>');
  }
]);
angular.module('template/pagination/pagination.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/pagination/pagination.html', '<ul class="pagination">\n' + '  <li ng-repeat="page in pages" ng-class="{active: page.active, disabled: page.disabled}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' + '</ul>');
  }
]);
angular.module('template/tooltip/tooltip-html-unsafe-popup.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/tooltip/tooltip-html-unsafe-popup.html', '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n' + '</div>\n' + '');
  }
]);
angular.module('template/tooltip/tooltip-popup.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/tooltip/tooltip-popup.html', '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind="content"></div>\n' + '</div>\n' + '');
  }
]);
angular.module('template/popover/popover.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/popover/popover.html', '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="arrow"></div>\n' + '\n' + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n' + '      <div class="popover-content" ng-bind="content"></div>\n' + '  </div>\n' + '</div>\n' + '');
  }
]);
angular.module('template/progressbar/bar.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/progressbar/bar.html', '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div>');
  }
]);
angular.module('template/progressbar/progress.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/progressbar/progress.html', '<div class="progress" ng-transclude></div>');
  }
]);
angular.module('template/progressbar/progressbar.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/progressbar/progressbar.html', '<div class="progress"><div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div></div>');
  }
]);
angular.module('template/rating/rating.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/rating/rating.html', '<span ng-mouseleave="reset()">\n' + '    <i ng-repeat="r in range" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < val && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')"></i>\n' + '</span>');
  }
]);
angular.module('template/tabs/tab.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/tabs/tab.html', '<li ng-class="{active: active, disabled: disabled}">\n' + '  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n' + '</li>\n' + '');
  }
]);
angular.module('template/tabs/tabset-titles.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/tabs/tabset-titles.html', '<ul class="nav {{type && \'nav-\' + type}}" ng-class="{\'nav-stacked\': vertical}">\n' + '</ul>\n' + '');
  }
]);
angular.module('template/tabs/tabset.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/tabs/tabset.html', '\n' + '<div class="tabbable">\n' + '  <ul class="nav {{type && \'nav-\' + type}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n' + '  <div class="tab-content">\n' + '    <div class="tab-pane" \n' + '         ng-repeat="tab in tabs" \n' + '         ng-class="{active: tab.active}"\n' + '         tab-content-transclude="tab">\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '');
  }
]);
angular.module('template/timepicker/timepicker.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/timepicker/timepicker.html', '<table>\n' + '\t<tbody>\n' + '\t\t<tr class="text-center">\n' + '\t\t\t<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '\t\t\t<td>&nbsp;</td>\n' + '\t\t\t<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '\t\t\t<td ng-show="showMeridian"></td>\n' + '\t\t</tr>\n' + '\t\t<tr>\n' + '\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n' + '\t\t\t\t<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n' + '\t\t\t</td>\n' + '\t\t\t<td>:</td>\n' + '\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n' + '\t\t\t\t<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n' + '\t\t\t</td>\n' + '\t\t\t<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n' + '\t\t</tr>\n' + '\t\t<tr class="text-center">\n' + '\t\t\t<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '\t\t\t<td>&nbsp;</td>\n' + '\t\t\t<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '\t\t\t<td ng-show="showMeridian"></td>\n' + '\t\t</tr>\n' + '\t</tbody>\n' + '</table>\n' + '');
  }
]);
angular.module('template/typeahead/typeahead-match.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/typeahead/typeahead-match.html', '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>');
  }
]);
angular.module('template/typeahead/typeahead-popup.html', []).run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('template/typeahead/typeahead-popup.html', '<ul class="dropdown-menu" ng-style="{display: isOpen()&&\'block\' || \'none\', top: position.top+\'px\', left: position.left+\'px\'}">\n' + '    <li ng-repeat="match in matches" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)">\n' + '        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' + '    </li>\n' + '</ul>');
  }
]);
'use strict';
angular.module('ui.alias', []).config([
  '$compileProvider',
  'uiAliasConfig',
  function ($compileProvider, uiAliasConfig) {
    uiAliasConfig = uiAliasConfig || {};
    angular.forEach(uiAliasConfig, function (config, alias) {
      if (angular.isString(config)) {
        config = {
          replace: true,
          template: config
        };
      }
      $compileProvider.directive(alias, function () {
        return config;
      });
    });
  }
]);
'use strict';
angular.module('ui.event', []).directive('uiEvent', [
  '$parse',
  function ($parse) {
    return function ($scope, elm, attrs) {
      var events = $scope.$eval(attrs.uiEvent);
      angular.forEach(events, function (uiEvent, eventName) {
        var fn = $parse(uiEvent);
        elm.bind(eventName, function (evt) {
          var params = Array.prototype.slice.call(arguments);
          params = params.splice(1);
          fn($scope, {
            $event: evt,
            $params: params
          });
          if (!$scope.$$phase) {
            $scope.$apply();
          }
        });
      });
    };
  }
]);
'use strict';
angular.module('ui.format', []).filter('format', function () {
  return function (value, replace) {
    var target = value;
    if (angular.isString(target) && replace !== undefined) {
      if (!angular.isArray(replace) && !angular.isObject(replace)) {
        replace = [replace];
      }
      if (angular.isArray(replace)) {
        var rlen = replace.length;
        var rfx = function (str, i) {
          i = parseInt(i, 10);
          return i >= 0 && i < rlen ? replace[i] : str;
        };
        target = target.replace(/\$([0-9]+)/g, rfx);
      } else {
        angular.forEach(replace, function (value, key) {
          target = target.split(':' + key).join(value);
        });
      }
    }
    return target;
  };
});
'use strict';
angular.module('ui.highlight', []).filter('highlight', function () {
  return function (text, search, caseSensitive) {
    if (search || angular.isNumber(search)) {
      text = text.toString();
      search = search.toString();
      if (caseSensitive) {
        return text.split(search).join('<span class="ui-match">' + search + '</span>');
      } else {
        return text.replace(new RegExp(search, 'gi'), '<span class="ui-match">$&</span>');
      }
    } else {
      return text;
    }
  };
});
'use strict';
angular.module('ui.include', []).directive('uiInclude', [
  '$http',
  '$templateCache',
  '$anchorScroll',
  '$compile',
  function ($http, $templateCache, $anchorScroll, $compile) {
    return {
      restrict: 'ECA',
      terminal: true,
      compile: function (element, attr) {
        var srcExp = attr.uiInclude || attr.src, fragExp = attr.fragment || '', onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
        return function (scope, element) {
          var changeCounter = 0, childScope;
          var clearContent = function () {
            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }
            element.html('');
          };
          function ngIncludeWatchAction() {
            var thisChangeId = ++changeCounter;
            var src = scope.$eval(srcExp);
            var fragment = scope.$eval(fragExp);
            if (src) {
              $http.get(src, { cache: $templateCache }).success(function (response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                if (childScope) {
                  childScope.$destroy();
                }
                childScope = scope.$new();
                var contents;
                if (fragment) {
                  contents = angular.element('<div/>').html(response).find(fragment);
                } else {
                  contents = angular.element('<div/>').html(response).contents();
                }
                element.html(contents);
                $compile(contents)(childScope);
                if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
                childScope.$emit('$includeContentLoaded');
                scope.$eval(onloadExp);
              }).error(function () {
                if (thisChangeId === changeCounter) {
                  clearContent();
                }
              });
            } else {
              clearContent();
            }
          }
          scope.$watch(fragExp, ngIncludeWatchAction);
          scope.$watch(srcExp, ngIncludeWatchAction);
        };
      }
    };
  }
]);
'use strict';
angular.module('ui.indeterminate', []).directive('uiIndeterminate', [function () {
    return {
      compile: function (tElm, tAttrs) {
        if (!tAttrs.type || tAttrs.type.toLowerCase() !== 'checkbox') {
          return angular.noop;
        }
        return function ($scope, elm, attrs) {
          $scope.$watch(attrs.uiIndeterminate, function (newVal) {
            elm[0].indeterminate = !!newVal;
          });
        };
      }
    };
  }]);
'use strict';
angular.module('ui.inflector', []).filter('inflector', function () {
  function ucwords(text) {
    return text.replace(/^([a-z])|\s+([a-z])/g, function ($1) {
      return $1.toUpperCase();
    });
  }
  function breakup(text, separator) {
    return text.replace(/[A-Z]/g, function (match) {
      return separator + match;
    });
  }
  var inflectors = {
      humanize: function (value) {
        return ucwords(breakup(value, ' ').split('_').join(' '));
      },
      underscore: function (value) {
        return value.substr(0, 1).toLowerCase() + breakup(value.substr(1), '_').toLowerCase().split(' ').join('_');
      },
      variable: function (value) {
        value = value.substr(0, 1).toLowerCase() + ucwords(value.split('_').join(' ')).substr(1).split(' ').join('');
        return value;
      }
    };
  return function (text, inflector) {
    if (inflector !== false && angular.isString(text)) {
      inflector = inflector || 'humanize';
      return inflectors[inflector](text);
    } else {
      return text;
    }
  };
});
'use strict';
angular.module('ui.jq', []).value('uiJqConfig', {}).directive('uiJq', [
  'uiJqConfig',
  '$timeout',
  function uiJqInjectingFunction(uiJqConfig, $timeout) {
    return {
      restrict: 'A',
      compile: function uiJqCompilingFunction(tElm, tAttrs) {
        if (!angular.isFunction(tElm[tAttrs.uiJq])) {
          throw new Error('ui-jq: The "' + tAttrs.uiJq + '" function does not exist');
        }
        var options = uiJqConfig && uiJqConfig[tAttrs.uiJq];
        return function uiJqLinkingFunction(scope, elm, attrs) {
          var linkOptions = [];
          if (attrs.uiOptions) {
            linkOptions = scope.$eval('[' + attrs.uiOptions + ']');
            if (angular.isObject(options) && angular.isObject(linkOptions[0])) {
              linkOptions[0] = angular.extend({}, options, linkOptions[0]);
            }
          } else if (options) {
            linkOptions = [options];
          }
          if (attrs.ngModel && elm.is('select,input,textarea')) {
            elm.bind('change', function () {
              elm.trigger('input');
            });
          }
          function callPlugin() {
            $timeout(function () {
              elm[attrs.uiJq].apply(elm, linkOptions);
            }, 0, false);
          }
          if (attrs.uiRefresh) {
            scope.$watch(attrs.uiRefresh, function () {
              callPlugin();
            });
          }
          callPlugin();
        };
      }
    };
  }
]);
'use strict';
angular.module('ui.keypress', []).factory('keypressHelper', [
  '$parse',
  function keypress($parse) {
    var keysByCode = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'insert',
        46: 'delete'
      };
    var capitaliseFirstLetter = function (string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return function (mode, scope, elm, attrs) {
      var params, combinations = [];
      params = scope.$eval(attrs['ui' + capitaliseFirstLetter(mode)]);
      angular.forEach(params, function (v, k) {
        var combination, expression;
        expression = $parse(v);
        angular.forEach(k.split(' '), function (variation) {
          combination = {
            expression: expression,
            keys: {}
          };
          angular.forEach(variation.split('-'), function (value) {
            combination.keys[value] = true;
          });
          combinations.push(combination);
        });
      });
      elm.bind(mode, function (event) {
        var metaPressed = !!(event.metaKey && !event.ctrlKey);
        var altPressed = !!event.altKey;
        var ctrlPressed = !!event.ctrlKey;
        var shiftPressed = !!event.shiftKey;
        var keyCode = event.keyCode;
        if (mode === 'keypress' && !shiftPressed && keyCode >= 97 && keyCode <= 122) {
          keyCode = keyCode - 32;
        }
        angular.forEach(combinations, function (combination) {
          var mainKeyPressed = combination.keys[keysByCode[keyCode]] || combination.keys[keyCode.toString()];
          var metaRequired = !!combination.keys.meta;
          var altRequired = !!combination.keys.alt;
          var ctrlRequired = !!combination.keys.ctrl;
          var shiftRequired = !!combination.keys.shift;
          if (mainKeyPressed && metaRequired === metaPressed && altRequired === altPressed && ctrlRequired === ctrlPressed && shiftRequired === shiftPressed) {
            scope.$apply(function () {
              combination.expression(scope, { '$event': event });
            });
          }
        });
      });
    };
  }
]);
angular.module('ui.keypress').directive('uiKeydown', [
  'keypressHelper',
  function (keypressHelper) {
    return {
      link: function (scope, elm, attrs) {
        keypressHelper('keydown', scope, elm, attrs);
      }
    };
  }
]);
angular.module('ui.keypress').directive('uiKeypress', [
  'keypressHelper',
  function (keypressHelper) {
    return {
      link: function (scope, elm, attrs) {
        keypressHelper('keypress', scope, elm, attrs);
      }
    };
  }
]);
angular.module('ui.keypress').directive('uiKeyup', [
  'keypressHelper',
  function (keypressHelper) {
    return {
      link: function (scope, elm, attrs) {
        keypressHelper('keyup', scope, elm, attrs);
      }
    };
  }
]);
'use strict';
angular.module('ui.mask', []).value('uiMaskConfig', {
  'maskDefinitions': {
    '9': /\d/,
    'A': /[a-zA-Z]/,
    '*': /[a-zA-Z0-9]/
  }
}).directive('uiMask', [
  'uiMaskConfig',
  function (maskConfig) {
    return {
      priority: 100,
      require: 'ngModel',
      restrict: 'A',
      compile: function uiMaskCompilingFunction() {
        var options = maskConfig;
        return function uiMaskLinkingFunction(scope, iElement, iAttrs, controller) {
          var maskProcessed = false, eventsBound = false, maskCaretMap, maskPatterns, maskPlaceholder, maskComponents, minRequiredLength, value, valueMasked, isValid, originalPlaceholder = iAttrs.placeholder, originalMaxlength = iAttrs.maxlength, oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;
          function initialize(maskAttr) {
            if (!angular.isDefined(maskAttr)) {
              return uninitialize();
            }
            processRawMask(maskAttr);
            if (!maskProcessed) {
              return uninitialize();
            }
            initializeElement();
            bindEventListeners();
            return true;
          }
          function initPlaceholder(placeholderAttr) {
            if (!angular.isDefined(placeholderAttr)) {
              return;
            }
            maskPlaceholder = placeholderAttr;
            if (maskProcessed) {
              eventHandler();
            }
          }
          function formatter(fromModelValue) {
            if (!maskProcessed) {
              return fromModelValue;
            }
            value = unmaskValue(fromModelValue || '');
            isValid = validateValue(value);
            controller.$setValidity('mask', isValid);
            return isValid && value.length ? maskValue(value) : undefined;
          }
          function parser(fromViewValue) {
            if (!maskProcessed) {
              return fromViewValue;
            }
            value = unmaskValue(fromViewValue || '');
            isValid = validateValue(value);
            controller.$viewValue = value.length ? maskValue(value) : '';
            controller.$setValidity('mask', isValid);
            if (value === '' && controller.$error.required !== undefined) {
              controller.$setValidity('required', false);
            }
            return isValid ? value : undefined;
          }
          var linkOptions = {};
          if (iAttrs.uiOptions) {
            linkOptions = scope.$eval('[' + iAttrs.uiOptions + ']');
            if (angular.isObject(linkOptions[0])) {
              linkOptions = function (original, current) {
                for (var i in original) {
                  if (Object.prototype.hasOwnProperty.call(original, i)) {
                    if (!current[i]) {
                      current[i] = angular.copy(original[i]);
                    } else {
                      angular.extend(current[i], original[i]);
                    }
                  }
                }
                return current;
              }(options, linkOptions[0]);
            }
          } else {
            linkOptions = options;
          }
          iAttrs.$observe('uiMask', initialize);
          iAttrs.$observe('placeholder', initPlaceholder);
          controller.$formatters.push(formatter);
          controller.$parsers.push(parser);
          function uninitialize() {
            maskProcessed = false;
            unbindEventListeners();
            if (angular.isDefined(originalPlaceholder)) {
              iElement.attr('placeholder', originalPlaceholder);
            } else {
              iElement.removeAttr('placeholder');
            }
            if (angular.isDefined(originalMaxlength)) {
              iElement.attr('maxlength', originalMaxlength);
            } else {
              iElement.removeAttr('maxlength');
            }
            iElement.val(controller.$modelValue);
            controller.$viewValue = controller.$modelValue;
            return false;
          }
          function initializeElement() {
            value = oldValueUnmasked = unmaskValue(controller.$modelValue || '');
            valueMasked = oldValue = maskValue(value);
            isValid = validateValue(value);
            var viewValue = isValid && value.length ? valueMasked : '';
            if (iAttrs.maxlength) {
              iElement.attr('maxlength', maskCaretMap[maskCaretMap.length - 1] * 2);
            }
            iElement.attr('placeholder', maskPlaceholder);
            iElement.val(viewValue);
            controller.$viewValue = viewValue;
          }
          function bindEventListeners() {
            if (eventsBound) {
              return;
            }
            iElement.bind('blur', blurHandler);
            iElement.bind('mousedown mouseup', mouseDownUpHandler);
            iElement.bind('input keyup click focus', eventHandler);
            eventsBound = true;
          }
          function unbindEventListeners() {
            if (!eventsBound) {
              return;
            }
            iElement.unbind('blur', blurHandler);
            iElement.unbind('mousedown', mouseDownUpHandler);
            iElement.unbind('mouseup', mouseDownUpHandler);
            iElement.unbind('input', eventHandler);
            iElement.unbind('keyup', eventHandler);
            iElement.unbind('click', eventHandler);
            iElement.unbind('focus', eventHandler);
            eventsBound = false;
          }
          function validateValue(value) {
            return value.length ? value.length >= minRequiredLength : true;
          }
          function unmaskValue(value) {
            var valueUnmasked = '', maskPatternsCopy = maskPatterns.slice();
            value = value.toString();
            angular.forEach(maskComponents, function (component) {
              value = value.replace(component, '');
            });
            angular.forEach(value.split(''), function (chr) {
              if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                valueUnmasked += chr;
                maskPatternsCopy.shift();
              }
            });
            return valueUnmasked;
          }
          function maskValue(unmaskedValue) {
            var valueMasked = '', maskCaretMapCopy = maskCaretMap.slice();
            angular.forEach(maskPlaceholder.split(''), function (chr, i) {
              if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                valueMasked += unmaskedValue.charAt(0) || '_';
                unmaskedValue = unmaskedValue.substr(1);
                maskCaretMapCopy.shift();
              } else {
                valueMasked += chr;
              }
            });
            return valueMasked;
          }
          function getPlaceholderChar(i) {
            var placeholder = iAttrs.placeholder;
            if (typeof placeholder !== 'undefined' && placeholder[i]) {
              return placeholder[i];
            } else {
              return '_';
            }
          }
          function getMaskComponents() {
            return maskPlaceholder.replace(/[_]+/g, '_').replace(/([^_]+)([a-zA-Z0-9])([^_])/g, '$1$2_$3').split('_');
          }
          function processRawMask(mask) {
            var characterCount = 0;
            maskCaretMap = [];
            maskPatterns = [];
            maskPlaceholder = '';
            if (typeof mask === 'string') {
              minRequiredLength = 0;
              var isOptional = false, splitMask = mask.split('');
              angular.forEach(splitMask, function (chr, i) {
                if (linkOptions.maskDefinitions[chr]) {
                  maskCaretMap.push(characterCount);
                  maskPlaceholder += getPlaceholderChar(i);
                  maskPatterns.push(linkOptions.maskDefinitions[chr]);
                  characterCount++;
                  if (!isOptional) {
                    minRequiredLength++;
                  }
                } else if (chr === '?') {
                  isOptional = true;
                } else {
                  maskPlaceholder += chr;
                  characterCount++;
                }
              });
            }
            maskCaretMap.push(maskCaretMap.slice().pop() + 1);
            maskComponents = getMaskComponents();
            maskProcessed = maskCaretMap.length > 1 ? true : false;
          }
          function blurHandler() {
            oldCaretPosition = 0;
            oldSelectionLength = 0;
            if (!isValid || value.length === 0) {
              valueMasked = '';
              iElement.val('');
              scope.$apply(function () {
                controller.$setViewValue('');
              });
            }
          }
          function mouseDownUpHandler(e) {
            if (e.type === 'mousedown') {
              iElement.bind('mouseout', mouseoutHandler);
            } else {
              iElement.unbind('mouseout', mouseoutHandler);
            }
          }
          iElement.bind('mousedown mouseup', mouseDownUpHandler);
          function mouseoutHandler() {
            oldSelectionLength = getSelectionLength(this);
            iElement.unbind('mouseout', mouseoutHandler);
          }
          function eventHandler(e) {
            e = e || {};
            var eventWhich = e.which, eventType = e.type;
            if (eventWhich === 16 || eventWhich === 91) {
              return;
            }
            var val = iElement.val(), valOld = oldValue, valMasked, valUnmasked = unmaskValue(val), valUnmaskedOld = oldValueUnmasked, valAltered = false, caretPos = getCaretPosition(this) || 0, caretPosOld = oldCaretPosition || 0, caretPosDelta = caretPos - caretPosOld, caretPosMin = maskCaretMap[0], caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(), selectionLenOld = oldSelectionLength || 0, isSelected = getSelectionLength(this) > 0, wasSelected = selectionLenOld > 0, isAddition = val.length > valOld.length || selectionLenOld && val.length > valOld.length - selectionLenOld, isDeletion = val.length < valOld.length || selectionLenOld && val.length === valOld.length - selectionLenOld, isSelection = eventWhich >= 37 && eventWhich <= 40 && e.shiftKey, isKeyLeftArrow = eventWhich === 37, isKeyBackspace = eventWhich === 8 || eventType !== 'keyup' && isDeletion && caretPosDelta === -1, isKeyDelete = eventWhich === 46 || eventType !== 'keyup' && isDeletion && caretPosDelta === 0 && !wasSelected, caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === 'click') && caretPos > caretPosMin;
            oldSelectionLength = getSelectionLength(this);
            if (isSelection || isSelected && (eventType === 'click' || eventType === 'keyup')) {
              return;
            }
            if (eventType === 'input' && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
              while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                caretPos--;
              }
              while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                caretPos++;
              }
              var charIndex = maskCaretMap.indexOf(caretPos);
              valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
              valAltered = true;
            }
            valMasked = maskValue(valUnmasked);
            oldValue = valMasked;
            oldValueUnmasked = valUnmasked;
            iElement.val(valMasked);
            if (valAltered) {
              scope.$apply(function () {
                controller.$setViewValue(valUnmasked);
              });
            }
            if (isAddition && caretPos <= caretPosMin) {
              caretPos = caretPosMin + 1;
            }
            if (caretBumpBack) {
              caretPos--;
            }
            caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;
            while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
              caretPos += caretBumpBack ? -1 : 1;
            }
            if (caretBumpBack && caretPos < caretPosMax || isAddition && !isValidCaretPosition(caretPosOld)) {
              caretPos++;
            }
            oldCaretPosition = caretPos;
            setCaretPosition(this, caretPos);
          }
          function isValidCaretPosition(pos) {
            return maskCaretMap.indexOf(pos) > -1;
          }
          function getCaretPosition(input) {
            if (!input)
              return 0;
            if (input.selectionStart !== undefined) {
              return input.selectionStart;
            } else if (document.selection) {
              input.focus();
              var selection = document.selection.createRange();
              selection.moveStart('character', -input.value.length);
              return selection.text.length;
            }
            return 0;
          }
          function setCaretPosition(input, pos) {
            if (!input)
              return 0;
            if (input.offsetWidth === 0 || input.offsetHeight === 0) {
              return;
            }
            if (input.setSelectionRange) {
              input.focus();
              input.setSelectionRange(pos, pos);
            } else if (input.createTextRange) {
              var range = input.createTextRange();
              range.collapse(true);
              range.moveEnd('character', pos);
              range.moveStart('character', pos);
              range.select();
            }
          }
          function getSelectionLength(input) {
            if (!input)
              return 0;
            if (input.selectionStart !== undefined) {
              return input.selectionEnd - input.selectionStart;
            }
            if (document.selection) {
              return document.selection.createRange().text.length;
            }
            return 0;
          }
          if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function (searchElement) {
              if (this === null) {
                throw new TypeError();
              }
              var t = Object(this);
              var len = t.length >>> 0;
              if (len === 0) {
                return -1;
              }
              var n = 0;
              if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n !== n) {
                  n = 0;
                } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                  n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
              }
              if (n >= len) {
                return -1;
              }
              var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
              for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                  return k;
                }
              }
              return -1;
            };
          }
        };
      }
    };
  }
]);
'use strict';
angular.module('ui.reset', []).value('uiResetConfig', null).directive('uiReset', [
  'uiResetConfig',
  function (uiResetConfig) {
    var resetValue = null;
    if (uiResetConfig !== undefined) {
      resetValue = uiResetConfig;
    }
    return {
      require: 'ngModel',
      link: function (scope, elm, attrs, ctrl) {
        var aElement;
        aElement = angular.element('<a class="ui-reset" />');
        elm.wrap('<span class="ui-resetwrap" />').after(aElement);
        aElement.bind('click', function (e) {
          e.preventDefault();
          scope.$apply(function () {
            if (attrs.uiReset) {
              ctrl.$setViewValue(scope.$eval(attrs.uiReset));
            } else {
              ctrl.$setViewValue(resetValue);
            }
            ctrl.$render();
          });
        });
      }
    };
  }
]);
'use strict';
angular.module('ui.route', []).directive('uiRoute', [
  '$location',
  '$parse',
  function ($location, $parse) {
    return {
      restrict: 'AC',
      scope: true,
      compile: function (tElement, tAttrs) {
        var useProperty;
        if (tAttrs.uiRoute) {
          useProperty = 'uiRoute';
        } else if (tAttrs.ngHref) {
          useProperty = 'ngHref';
        } else if (tAttrs.href) {
          useProperty = 'href';
        } else {
          throw new Error('uiRoute missing a route or href property on ' + tElement[0]);
        }
        return function ($scope, elm, attrs) {
          var modelSetter = $parse(attrs.ngModel || attrs.routeModel || '$uiRoute').assign;
          var watcher = angular.noop;
          function staticWatcher(newVal) {
            var hash = newVal.indexOf('#');
            if (hash > -1) {
              newVal = newVal.substr(hash + 1);
            }
            watcher = function watchHref() {
              modelSetter($scope, $location.path().indexOf(newVal) > -1);
            };
            watcher();
          }
          function regexWatcher(newVal) {
            var hash = newVal.indexOf('#');
            if (hash > -1) {
              newVal = newVal.substr(hash + 1);
            }
            watcher = function watchRegex() {
              var regexp = new RegExp('^' + newVal + '$', ['i']);
              modelSetter($scope, regexp.test($location.path()));
            };
            watcher();
          }
          switch (useProperty) {
          case 'uiRoute':
            if (attrs.uiRoute) {
              regexWatcher(attrs.uiRoute);
            } else {
              attrs.$observe('uiRoute', regexWatcher);
            }
            break;
          case 'ngHref':
            if (attrs.ngHref) {
              staticWatcher(attrs.ngHref);
            } else {
              attrs.$observe('ngHref', staticWatcher);
            }
            break;
          case 'href':
            staticWatcher(attrs.href);
          }
          $scope.$on('$routeChangeSuccess', function () {
            watcher();
          });
          $scope.$on('$stateChangeSuccess', function () {
            watcher();
          });
        };
      }
    };
  }
]);
'use strict';
angular.module('ui.scroll.jqlite', ['ui.scroll']).service('jqLiteExtras', [
  '$log',
  '$window',
  function (console, window) {
    return {
      registerFor: function (element) {
        var convertToPx, css, getMeasurements, getStyle, getWidthHeight, isWindow, scrollTo;
        css = angular.element.prototype.css;
        element.prototype.css = function (name, value) {
          var elem, self;
          self = this;
          elem = self[0];
          if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {
            return css.call(self, name, value);
          }
        };
        isWindow = function (obj) {
          return obj && obj.document && obj.location && obj.alert && obj.setInterval;
        };
        scrollTo = function (self, direction, value) {
          var elem, method, preserve, prop, _ref;
          elem = self[0];
          _ref = {
            top: [
              'scrollTop',
              'pageYOffset',
              'scrollLeft'
            ],
            left: [
              'scrollLeft',
              'pageXOffset',
              'scrollTop'
            ]
          }[direction], method = _ref[0], prop = _ref[1], preserve = _ref[2];
          if (isWindow(elem)) {
            if (angular.isDefined(value)) {
              return elem.scrollTo(self[preserve].call(self), value);
            } else {
              if (prop in elem) {
                return elem[prop];
              } else {
                return elem.document.documentElement[method];
              }
            }
          } else {
            if (angular.isDefined(value)) {
              return elem[method] = value;
            } else {
              return elem[method];
            }
          }
        };
        if (window.getComputedStyle) {
          getStyle = function (elem) {
            return window.getComputedStyle(elem, null);
          };
          convertToPx = function (elem, value) {
            return parseFloat(value);
          };
        } else {
          getStyle = function (elem) {
            return elem.currentStyle;
          };
          convertToPx = function (elem, value) {
            var core_pnum, left, result, rnumnonpx, rs, rsLeft, style;
            core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
            rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');
            if (!rnumnonpx.test(value)) {
              return parseFloat(value);
            } else {
              style = elem.style;
              left = style.left;
              rs = elem.runtimeStyle;
              rsLeft = rs && rs.left;
              if (rs) {
                rs.left = style.left;
              }
              style.left = value;
              result = style.pixelLeft;
              style.left = left;
              if (rsLeft) {
                rs.left = rsLeft;
              }
              return result;
            }
          };
        }
        getMeasurements = function (elem, measure) {
          var base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB, _ref;
          if (isWindow(elem)) {
            base = document.documentElement[{
              height: 'clientHeight',
              width: 'clientWidth'
            }[measure]];
            return {
              base: base,
              padding: 0,
              border: 0,
              margin: 0
            };
          }
          _ref = {
            width: [
              elem.offsetWidth,
              'Left',
              'Right'
            ],
            height: [
              elem.offsetHeight,
              'Top',
              'Bottom'
            ]
          }[measure], base = _ref[0], dirA = _ref[1], dirB = _ref[2];
          computedStyle = getStyle(elem);
          paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;
          paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;
          borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;
          borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;
          computedMarginA = computedStyle['margin' + dirA];
          computedMarginB = computedStyle['margin' + dirB];
          marginA = convertToPx(elem, computedMarginA) || 0;
          marginB = convertToPx(elem, computedMarginB) || 0;
          return {
            base: base,
            padding: paddingA + paddingB,
            border: borderA + borderB,
            margin: marginA + marginB
          };
        };
        getWidthHeight = function (elem, direction, measure) {
          var computedStyle, measurements, result;
          measurements = getMeasurements(elem, direction);
          if (measurements.base > 0) {
            return {
              base: measurements.base - measurements.padding - measurements.border,
              outer: measurements.base,
              outerfull: measurements.base + measurements.margin
            }[measure];
          } else {
            computedStyle = getStyle(elem);
            result = computedStyle[direction];
            if (result < 0 || result === null) {
              result = elem.style[direction] || 0;
            }
            result = parseFloat(result) || 0;
            return {
              base: result - measurements.padding - measurements.border,
              outer: result,
              outerfull: result + measurements.padding + measurements.border + measurements.margin
            }[measure];
          }
        };
        return angular.forEach({
          before: function (newElem) {
            var children, elem, i, parent, self, _i, _ref;
            self = this;
            elem = self[0];
            parent = self.parent();
            children = parent.contents();
            if (children[0] === elem) {
              return parent.prepend(newElem);
            } else {
              for (i = _i = 1, _ref = children.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
                if (children[i] === elem) {
                  angular.element(children[i - 1]).after(newElem);
                  return;
                }
              }
              throw new Error('invalid DOM structure ' + elem.outerHTML);
            }
          },
          height: function (value) {
            var self;
            self = this;
            if (angular.isDefined(value)) {
              if (angular.isNumber(value)) {
                value = value + 'px';
              }
              return css.call(self, 'height', value);
            } else {
              return getWidthHeight(this[0], 'height', 'base');
            }
          },
          outerHeight: function (option) {
            return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');
          },
          offset: function (value) {
            var box, doc, docElem, elem, self, win;
            self = this;
            if (arguments.length) {
              if (value === void 0) {
                return self;
              } else {
                return value;
              }
            }
            box = {
              top: 0,
              left: 0
            };
            elem = self[0];
            doc = elem && elem.ownerDocument;
            if (!doc) {
              return;
            }
            docElem = doc.documentElement;
            if (elem.getBoundingClientRect) {
              box = elem.getBoundingClientRect();
            }
            win = doc.defaultView || doc.parentWindow;
            return {
              top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
              left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            };
          },
          scrollTop: function (value) {
            return scrollTo(this, 'top', value);
          },
          scrollLeft: function (value) {
            return scrollTo(this, 'left', value);
          }
        }, function (value, key) {
          if (!element.prototype[key]) {
            return element.prototype[key] = value;
          }
        });
      }
    };
  }
]).run([
  '$log',
  '$window',
  'jqLiteExtras',
  function (console, window, jqLiteExtras) {
    if (!window.jQuery) {
      return jqLiteExtras.registerFor(angular.element);
    }
  }
]);
'use strict';
angular.module('ui.scroll', []).directive('ngScrollViewport', [
  '$log',
  function () {
    return {
      controller: [
        '$scope',
        '$element',
        function (scope, element) {
          return element;
        }
      ]
    };
  }
]).directive('ngScroll', [
  '$log',
  '$injector',
  '$rootScope',
  '$timeout',
  function (console, $injector, $rootScope, $timeout) {
    return {
      require: ['?^ngScrollViewport'],
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function ($scope, $element, $attr, controllers) {
          var adapter, adjustBuffer, adjustRowHeight, bof, bottomVisiblePos, buffer, bufferPadding, bufferSize, clipBottom, clipTop, datasource, datasourceName, enqueueFetch, eof, eventListener, fetch, finalize, first, insert, isDatasource, isLoading, itemName, loading, match, next, pending, reload, removeFromBuffer, resizeHandler, scrollHandler, scrollHeight, shouldLoadBottom, shouldLoadTop, tempScope, topVisiblePos, viewport;
          match = $attr.ngScroll.match(/^\s*(\w+)\s+in\s+(\w+)\s*$/);
          if (!match) {
            throw new Error('Expected ngScroll in form of "item_ in _datasource_" but got "' + $attr.ngScroll + '"');
          }
          itemName = match[1];
          datasourceName = match[2];
          isDatasource = function (datasource) {
            return angular.isObject(datasource) && datasource.get && angular.isFunction(datasource.get);
          };
          datasource = $scope[datasourceName];
          if (!isDatasource(datasource)) {
            datasource = $injector.get(datasourceName);
            if (!isDatasource(datasource)) {
              throw new Error(datasourceName + ' is not a valid datasource');
            }
          }
          bufferSize = Math.max(3, +$attr.bufferSize || 10);
          bufferPadding = function () {
            return viewport.height() * Math.max(0.1, +$attr.padding || 0.1);
          };
          scrollHeight = function (elem) {
            return elem[0].scrollHeight || elem[0].document.documentElement.scrollHeight;
          };
          adapter = null;
          linker(tempScope = $scope.$new(), function (template) {
            var bottomPadding, createPadding, padding, repeaterType, topPadding, viewport;
            repeaterType = template[0].localName;
            if (repeaterType === 'dl') {
              throw new Error('ng-scroll directive does not support <' + template[0].localName + '> as a repeating tag: ' + template[0].outerHTML);
            }
            if (repeaterType !== 'li' && repeaterType !== 'tr') {
              repeaterType = 'div';
            }
            viewport = controllers[0] || angular.element(window);
            viewport.css({
              'overflow-y': 'auto',
              'display': 'block'
            });
            padding = function (repeaterType) {
              var div, result, table;
              switch (repeaterType) {
              case 'tr':
                table = angular.element('<table><tr><td><div></div></td></tr></table>');
                div = table.find('div');
                result = table.find('tr');
                result.paddingHeight = function () {
                  return div.height.apply(div, arguments);
                };
                return result;
              default:
                result = angular.element('<' + repeaterType + '></' + repeaterType + '>');
                result.paddingHeight = result.height;
                return result;
              }
            };
            createPadding = function (padding, element, direction) {
              element[{
                top: 'before',
                bottom: 'after'
              }[direction]](padding);
              return {
                paddingHeight: function () {
                  return padding.paddingHeight.apply(padding, arguments);
                },
                insert: function (element) {
                  return padding[{
                    top: 'after',
                    bottom: 'before'
                  }[direction]](element);
                }
              };
            };
            topPadding = createPadding(padding(repeaterType), element, 'top');
            bottomPadding = createPadding(padding(repeaterType), element, 'bottom');
            tempScope.$destroy();
            return adapter = {
              viewport: viewport,
              topPadding: topPadding.paddingHeight,
              bottomPadding: bottomPadding.paddingHeight,
              append: bottomPadding.insert,
              prepend: topPadding.insert,
              bottomDataPos: function () {
                return scrollHeight(viewport) - bottomPadding.paddingHeight();
              },
              topDataPos: function () {
                return topPadding.paddingHeight();
              }
            };
          });
          viewport = adapter.viewport;
          first = 1;
          next = 1;
          buffer = [];
          pending = [];
          eof = false;
          bof = false;
          loading = datasource.loading || function () {
          };
          isLoading = false;
          removeFromBuffer = function (start, stop) {
            var i, _i;
            for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
              buffer[i].scope.$destroy();
              buffer[i].element.remove();
            }
            return buffer.splice(start, stop - start);
          };
          reload = function () {
            first = 1;
            next = 1;
            removeFromBuffer(0, buffer.length);
            adapter.topPadding(0);
            adapter.bottomPadding(0);
            pending = [];
            eof = false;
            bof = false;
            return adjustBuffer(false);
          };
          bottomVisiblePos = function () {
            return viewport.scrollTop() + viewport.height();
          };
          topVisiblePos = function () {
            return viewport.scrollTop();
          };
          shouldLoadBottom = function () {
            return !eof && adapter.bottomDataPos() < bottomVisiblePos() + bufferPadding();
          };
          clipBottom = function () {
            var bottomHeight, i, itemHeight, overage, _i, _ref;
            bottomHeight = 0;
            overage = 0;
            for (i = _i = _ref = buffer.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
              itemHeight = buffer[i].element.outerHeight(true);
              if (adapter.bottomDataPos() - bottomHeight - itemHeight > bottomVisiblePos() + bufferPadding()) {
                bottomHeight += itemHeight;
                overage++;
                eof = false;
              } else {
                break;
              }
            }
            if (overage > 0) {
              adapter.bottomPadding(adapter.bottomPadding() + bottomHeight);
              removeFromBuffer(buffer.length - overage, buffer.length);
              next -= overage;
              return console.log('clipped off bottom ' + overage + ' bottom padding ' + adapter.bottomPadding());
            }
          };
          shouldLoadTop = function () {
            return !bof && adapter.topDataPos() > topVisiblePos() - bufferPadding();
          };
          clipTop = function () {
            var item, itemHeight, overage, topHeight, _i, _len;
            topHeight = 0;
            overage = 0;
            for (_i = 0, _len = buffer.length; _i < _len; _i++) {
              item = buffer[_i];
              itemHeight = item.element.outerHeight(true);
              if (adapter.topDataPos() + topHeight + itemHeight < topVisiblePos() - bufferPadding()) {
                topHeight += itemHeight;
                overage++;
                bof = false;
              } else {
                break;
              }
            }
            if (overage > 0) {
              adapter.topPadding(adapter.topPadding() + topHeight);
              removeFromBuffer(0, overage);
              first += overage;
              return console.log('clipped off top ' + overage + ' top padding ' + adapter.topPadding());
            }
          };
          enqueueFetch = function (direction, scrolling) {
            if (!isLoading) {
              isLoading = true;
              loading(true);
            }
            if (pending.push(direction) === 1) {
              return fetch(scrolling);
            }
          };
          insert = function (index, item) {
            var itemScope, toBeAppended, wrapper;
            itemScope = $scope.$new();
            itemScope[itemName] = item;
            toBeAppended = index > first;
            itemScope.$index = index;
            if (toBeAppended) {
              itemScope.$index--;
            }
            wrapper = { scope: itemScope };
            linker(itemScope, function (clone) {
              wrapper.element = clone;
              if (toBeAppended) {
                if (index === next) {
                  adapter.append(clone);
                  return buffer.push(wrapper);
                } else {
                  buffer[index - first].element.after(clone);
                  return buffer.splice(index - first + 1, 0, wrapper);
                }
              } else {
                adapter.prepend(clone);
                return buffer.unshift(wrapper);
              }
            });
            return {
              appended: toBeAppended,
              wrapper: wrapper
            };
          };
          adjustRowHeight = function (appended, wrapper) {
            var newHeight;
            if (appended) {
              return adapter.bottomPadding(Math.max(0, adapter.bottomPadding() - wrapper.element.outerHeight(true)));
            } else {
              newHeight = adapter.topPadding() - wrapper.element.outerHeight(true);
              if (newHeight >= 0) {
                return adapter.topPadding(newHeight);
              } else {
                return viewport.scrollTop(viewport.scrollTop() + wrapper.element.outerHeight(true));
              }
            }
          };
          adjustBuffer = function (scrolling, newItems, finalize) {
            var doAdjustment;
            doAdjustment = function () {
              console.log('top {actual=' + adapter.topDataPos() + ' visible from=' + topVisiblePos() + ' bottom {visible through=' + bottomVisiblePos() + ' actual=' + adapter.bottomDataPos() + '}');
              if (shouldLoadBottom()) {
                enqueueFetch(true, scrolling);
              } else {
                if (shouldLoadTop()) {
                  enqueueFetch(false, scrolling);
                }
              }
              if (finalize) {
                return finalize();
              }
            };
            if (newItems) {
              return $timeout(function () {
                var row, _i, _len;
                for (_i = 0, _len = newItems.length; _i < _len; _i++) {
                  row = newItems[_i];
                  adjustRowHeight(row.appended, row.wrapper);
                }
                return doAdjustment();
              });
            } else {
              return doAdjustment();
            }
          };
          finalize = function (scrolling, newItems) {
            return adjustBuffer(scrolling, newItems, function () {
              pending.shift();
              if (pending.length === 0) {
                isLoading = false;
                return loading(false);
              } else {
                return fetch(scrolling);
              }
            });
          };
          fetch = function (scrolling) {
            var direction;
            direction = pending[0];
            if (direction) {
              if (buffer.length && !shouldLoadBottom()) {
                return finalize(scrolling);
              } else {
                return datasource.get(next, bufferSize, function (result) {
                  var item, newItems, _i, _len;
                  newItems = [];
                  if (result.length === 0) {
                    eof = true;
                    adapter.bottomPadding(0);
                    console.log('appended: requested ' + bufferSize + ' records starting from ' + next + ' recieved: eof');
                  } else {
                    clipTop();
                    for (_i = 0, _len = result.length; _i < _len; _i++) {
                      item = result[_i];
                      newItems.push(insert(++next, item));
                    }
                    console.log('appended: requested ' + bufferSize + ' received ' + result.length + ' buffer size ' + buffer.length + ' first ' + first + ' next ' + next);
                  }
                  return finalize(scrolling, newItems);
                });
              }
            } else {
              if (buffer.length && !shouldLoadTop()) {
                return finalize(scrolling);
              } else {
                return datasource.get(first - bufferSize, bufferSize, function (result) {
                  var i, newItems, _i, _ref;
                  newItems = [];
                  if (result.length === 0) {
                    bof = true;
                    adapter.topPadding(0);
                    console.log('prepended: requested ' + bufferSize + ' records starting from ' + (first - bufferSize) + ' recieved: bof');
                  } else {
                    clipBottom();
                    for (i = _i = _ref = result.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                      newItems.unshift(insert(--first, result[i]));
                    }
                    console.log('prepended: requested ' + bufferSize + ' received ' + result.length + ' buffer size ' + buffer.length + ' first ' + first + ' next ' + next);
                  }
                  return finalize(scrolling, newItems);
                });
              }
            }
          };
          resizeHandler = function () {
            if (!$rootScope.$$phase && !isLoading) {
              adjustBuffer(false);
              return $scope.$apply();
            }
          };
          viewport.bind('resize', resizeHandler);
          scrollHandler = function () {
            if (!$rootScope.$$phase && !isLoading) {
              adjustBuffer(true);
              return $scope.$apply();
            }
          };
          viewport.bind('scroll', scrollHandler);
          $scope.$watch(datasource.revision, function () {
            return reload();
          });
          if (datasource.scope) {
            eventListener = datasource.scope.$new();
          } else {
            eventListener = $scope.$new();
          }
          $scope.$on('$destroy', function () {
            eventListener.$destroy();
            viewport.unbind('resize', resizeHandler);
            return viewport.unbind('scroll', scrollHandler);
          });
          eventListener.$on('update.items', function (event, locator, newItem) {
            var wrapper, _fn, _i, _len, _ref;
            if (angular.isFunction(locator)) {
              _fn = function (wrapper) {
                return locator(wrapper.scope);
              };
              for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                wrapper = buffer[_i];
                _fn(wrapper);
              }
            } else {
              if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                buffer[locator - first - 1].scope[itemName] = newItem;
              }
            }
            return null;
          });
          eventListener.$on('delete.items', function (event, locator) {
            var i, item, temp, wrapper, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
            if (angular.isFunction(locator)) {
              temp = [];
              for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                item = buffer[_i];
                temp.unshift(item);
              }
              _fn = function (wrapper) {
                if (locator(wrapper.scope)) {
                  removeFromBuffer(temp.length - 1 - i, temp.length - i);
                  return next--;
                }
              };
              for (i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) {
                wrapper = temp[i];
                _fn(wrapper);
              }
            } else {
              if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                removeFromBuffer(locator - first - 1, locator - first);
                next--;
              }
            }
            for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
              item = buffer[i];
              item.scope.$index = first + i;
            }
            return adjustBuffer(false);
          });
          return eventListener.$on('insert.item', function (event, locator, item) {
            var i, inserted, temp, wrapper, _fn, _i, _j, _k, _len, _len1, _len2, _ref;
            inserted = [];
            if (angular.isFunction(locator)) {
              temp = [];
              for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                item = buffer[_i];
                temp.unshift(item);
              }
              _fn = function (wrapper) {
                var j, newItems, _k, _len2, _results;
                if (newItems = locator(wrapper.scope)) {
                  insert = function (index, newItem) {
                    insert(index, newItem);
                    return next++;
                  };
                  if (angular.isArray(newItems)) {
                    _results = [];
                    for (j = _k = 0, _len2 = newItems.length; _k < _len2; j = ++_k) {
                      item = newItems[j];
                      _results.push(inserted.push(insert(i + j, item)));
                    }
                    return _results;
                  } else {
                    return inserted.push(insert(i, newItems));
                  }
                }
              };
              for (i = _j = 0, _len1 = temp.length; _j < _len1; i = ++_j) {
                wrapper = temp[i];
                _fn(wrapper);
              }
            } else {
              if (0 <= (_ref = locator - first - 1) && _ref < buffer.length) {
                inserted.push(insert(locator, item));
                next++;
              }
            }
            for (i = _k = 0, _len2 = buffer.length; _k < _len2; i = ++_k) {
              item = buffer[i];
              item.scope.$index = first + i;
            }
            return adjustBuffer(false, inserted);
          });
        };
      }
    };
  }
]);
'use strict';
angular.module('ui.scrollfix', []).directive('uiScrollfix', [
  '$window',
  function ($window) {
    return {
      require: '^?uiScrollfixTarget',
      link: function (scope, elm, attrs, uiScrollfixTarget) {
        var top = elm[0].offsetTop, $target = uiScrollfixTarget && uiScrollfixTarget.$element || angular.element($window);
        if (!attrs.uiScrollfix) {
          attrs.uiScrollfix = top;
        } else if (typeof attrs.uiScrollfix === 'string') {
          if (attrs.uiScrollfix.charAt(0) === '-') {
            attrs.uiScrollfix = top - parseFloat(attrs.uiScrollfix.substr(1));
          } else if (attrs.uiScrollfix.charAt(0) === '+') {
            attrs.uiScrollfix = top + parseFloat(attrs.uiScrollfix.substr(1));
          }
        }
        function onScroll() {
          var offset;
          if (angular.isDefined($window.pageYOffset)) {
            offset = $window.pageYOffset;
          } else {
            var iebody = document.compatMode && document.compatMode !== 'BackCompat' ? document.documentElement : document.body;
            offset = iebody.scrollTop;
          }
          if (!elm.hasClass('ui-scrollfix') && offset > attrs.uiScrollfix) {
            elm.addClass('ui-scrollfix');
          } else if (elm.hasClass('ui-scrollfix') && offset < attrs.uiScrollfix) {
            elm.removeClass('ui-scrollfix');
          }
        }
        $target.on('scroll', onScroll);
        scope.$on('$destroy', function () {
          $target.off('scroll', onScroll);
        });
      }
    };
  }
]).directive('uiScrollfixTarget', [function () {
    return {
      controller: [
        '$element',
        function ($element) {
          this.$element = $element;
        }
      ]
    };
  }]);
'use strict';
angular.module('ui.showhide', []).directive('uiShow', [function () {
    return function (scope, elm, attrs) {
      scope.$watch(attrs.uiShow, function (newVal) {
        if (newVal) {
          elm.addClass('ui-show');
        } else {
          elm.removeClass('ui-show');
        }
      });
    };
  }]).directive('uiHide', [function () {
    return function (scope, elm, attrs) {
      scope.$watch(attrs.uiHide, function (newVal) {
        if (newVal) {
          elm.addClass('ui-hide');
        } else {
          elm.removeClass('ui-hide');
        }
      });
    };
  }]).directive('uiToggle', [function () {
    return function (scope, elm, attrs) {
      scope.$watch(attrs.uiToggle, function (newVal) {
        if (newVal) {
          elm.removeClass('ui-hide').addClass('ui-show');
        } else {
          elm.removeClass('ui-show').addClass('ui-hide');
        }
      });
    };
  }]);
'use strict';
angular.module('ui.unique', []).filter('unique', [
  '$parse',
  function ($parse) {
    return function (items, filterOn) {
      if (filterOn === false) {
        return items;
      }
      if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
        var newItems = [], get = angular.isString(filterOn) ? $parse(filterOn) : function (item) {
            return item;
          };
        var extractValueToCompare = function (item) {
          return angular.isObject(item) ? get(item) : item;
        };
        angular.forEach(items, function (item) {
          var isDuplicate = false;
          for (var i = 0; i < newItems.length; i++) {
            if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
              isDuplicate = true;
              break;
            }
          }
          if (!isDuplicate) {
            newItems.push(item);
          }
        });
        items = newItems;
      }
      return items;
    };
  }
]);
'use strict';
angular.module('ui.validate', []).directive('uiValidate', function () {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function (scope, elm, attrs, ctrl) {
      var validateFn, validators = {}, validateExpr = scope.$eval(attrs.uiValidate);
      if (!validateExpr) {
        return;
      }
      if (angular.isString(validateExpr)) {
        validateExpr = { validator: validateExpr };
      }
      angular.forEach(validateExpr, function (exprssn, key) {
        validateFn = function (valueToValidate) {
          var expression = scope.$eval(exprssn, { '$value': valueToValidate });
          if (angular.isObject(expression) && angular.isFunction(expression.then)) {
            expression.then(function () {
              ctrl.$setValidity(key, true);
            }, function () {
              ctrl.$setValidity(key, false);
            });
            return valueToValidate;
          } else if (expression) {
            ctrl.$setValidity(key, true);
            return valueToValidate;
          } else {
            ctrl.$setValidity(key, false);
            return undefined;
          }
        };
        validators[key] = validateFn;
        ctrl.$formatters.push(validateFn);
        ctrl.$parsers.push(validateFn);
      });
      function apply_watch(watch) {
        if (angular.isString(watch)) {
          scope.$watch(watch, function () {
            angular.forEach(validators, function (validatorFn) {
              validatorFn(ctrl.$modelValue);
            });
          });
          return;
        }
        if (angular.isArray(watch)) {
          angular.forEach(watch, function (expression) {
            scope.$watch(expression, function () {
              angular.forEach(validators, function (validatorFn) {
                validatorFn(ctrl.$modelValue);
              });
            });
          });
          return;
        }
        if (angular.isObject(watch)) {
          angular.forEach(watch, function (expression, validatorKey) {
            if (angular.isString(expression)) {
              scope.$watch(expression, function () {
                validators[validatorKey](ctrl.$modelValue);
              });
            }
            if (angular.isArray(expression)) {
              angular.forEach(expression, function (intExpression) {
                scope.$watch(intExpression, function () {
                  validators[validatorKey](ctrl.$modelValue);
                });
              });
            }
          });
        }
      }
      if (attrs.uiValidateWatch) {
        apply_watch(scope.$eval(attrs.uiValidateWatch));
      }
    }
  };
});
angular.module('ui.utils', [
  'ui.event',
  'ui.format',
  'ui.highlight',
  'ui.include',
  'ui.indeterminate',
  'ui.inflector',
  'ui.jq',
  'ui.keypress',
  'ui.mask',
  'ui.reset',
  'ui.route',
  'ui.scrollfix',
  'ui.scroll',
  'ui.scroll.jqlite',
  'ui.showhide',
  'ui.unique',
  'ui.validate'
]);
angular.module('ui.select2', []).value('uiSelect2Config', {}).directive('uiSelect2', [
  'uiSelect2Config',
  '$timeout',
  function (uiSelect2Config, $timeout) {
    var options = {};
    if (uiSelect2Config) {
      angular.extend(options, uiSelect2Config);
    }
    return {
      require: 'ngModel',
      priority: 1,
      compile: function (tElm, tAttrs) {
        var watch, repeatOption, repeatAttr, isSelect = tElm.is('select'), isMultiple = angular.isDefined(tAttrs.multiple);
        if (tElm.is('select')) {
          repeatOption = tElm.find('option[ng-repeat], option[data-ng-repeat]');
          if (repeatOption.length) {
            repeatAttr = repeatOption.attr('ng-repeat') || repeatOption.attr('data-ng-repeat');
            watch = jQuery.trim(repeatAttr.split('|')[0]).split(' ').pop();
          }
        }
        return function (scope, elm, attrs, controller) {
          var opts = angular.extend({}, options, scope.$eval(attrs.uiSelect2));
          var convertToAngularModel = function (select2_data) {
            var model;
            if (opts.simple_tags) {
              model = [];
              angular.forEach(select2_data, function (value, index) {
                model.push(value.id);
              });
            } else {
              model = select2_data;
            }
            return model;
          };
          var convertToSelect2Model = function (angular_data) {
            var model = [];
            if (!angular_data) {
              return model;
            }
            if (opts.simple_tags) {
              model = [];
              angular.forEach(angular_data, function (value, index) {
                model.push({
                  'id': value,
                  'text': value
                });
              });
            } else {
              model = angular_data;
            }
            return model;
          };
          if (isSelect) {
            delete opts.multiple;
            delete opts.initSelection;
          } else if (isMultiple) {
            opts.multiple = true;
          }
          if (controller) {
            scope.$watch(tAttrs.ngModel, function (current, old) {
              if (!current) {
                return;
              }
              if (current === old) {
                return;
              }
              controller.$render();
            }, true);
            controller.$render = function () {
              if (isSelect) {
                elm.select2('val', controller.$viewValue);
              } else {
                if (opts.multiple) {
                  var viewValue = controller.$viewValue;
                  if (angular.isString(viewValue)) {
                    viewValue = viewValue.split(',');
                  }
                  elm.select2('data', convertToSelect2Model(viewValue));
                } else {
                  if (angular.isObject(controller.$viewValue)) {
                    elm.select2('data', controller.$viewValue);
                  } else if (!controller.$viewValue) {
                    elm.select2('data', null);
                  } else {
                    elm.select2('val', controller.$viewValue);
                  }
                }
              }
            };
            if (watch) {
              scope.$watch(watch, function (newVal, oldVal, scope) {
                if (angular.equals(newVal, oldVal)) {
                  return;
                }
                $timeout(function () {
                  elm.select2('val', controller.$viewValue);
                  elm.trigger('change');
                  if (newVal && !oldVal && controller.$setPristine) {
                    controller.$setPristine(true);
                  }
                });
              });
            }
            controller.$parsers.push(function (value) {
              var div = elm.prev();
              div.toggleClass('ng-invalid', !controller.$valid).toggleClass('ng-valid', controller.$valid).toggleClass('ng-invalid-required', !controller.$valid).toggleClass('ng-valid-required', controller.$valid).toggleClass('ng-dirty', controller.$dirty).toggleClass('ng-pristine', controller.$pristine);
              return value;
            });
            if (!isSelect) {
              elm.bind('change', function (e) {
                e.stopImmediatePropagation();
                if (scope.$$phase || scope.$root.$$phase) {
                  return;
                }
                scope.$apply(function () {
                  controller.$setViewValue(convertToAngularModel(elm.select2('data')));
                });
              });
              if (opts.initSelection) {
                var initSelection = opts.initSelection;
                opts.initSelection = function (element, callback) {
                  initSelection(element, function (value) {
                    controller.$setViewValue(convertToAngularModel(value));
                    callback(value);
                  });
                };
              }
            }
          }
          elm.bind('$destroy', function () {
            elm.select2('destroy');
          });
          attrs.$observe('disabled', function (value) {
            elm.select2('enable', !value);
          });
          attrs.$observe('readonly', function (value) {
            elm.select2('readonly', !!value);
          });
          if (attrs.ngMultiple) {
            scope.$watch(attrs.ngMultiple, function (newVal) {
              attrs.$set('multiple', !!newVal);
              elm.select2(opts);
            });
          }
          $timeout(function () {
            elm.select2(opts);
            elm.val(controller.$viewValue);
            controller.$render();
            if (!opts.initSelection && !isSelect) {
              controller.$setViewValue(convertToAngularModel(elm.select2('data')));
            }
          });
        };
      }
    };
  }
]);
'use strict';
angular.module('ngExpress.bundles.ui', [
  'ui.bootstrap',
  'ui.select2',
  'ui.utils'
]);